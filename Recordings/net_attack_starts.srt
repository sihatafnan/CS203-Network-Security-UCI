1
00:00:00,000 --> 00:00:08,240
perverse a number of what's called autonomous systems. Some autonomous systems are called

2
00:00:08,240 --> 00:00:14,240
stomp, because you need stomp, meaning that they're like ISPs, that they provide services

3
00:00:14,240 --> 00:00:22,400
to individual customers. And then there are these transit or backbone ISPs that essentially

4
00:00:22,400 --> 00:00:28,480
do not deal with individual customers, but rather provide, well, just transit services.

5
00:00:30,000 --> 00:00:40,240
And so an autonomous system, as I think I have mentioned at least a couple of times,

6
00:00:40,240 --> 00:00:45,040
is a collection of resources under the control of a single administration.

7
00:00:45,920 --> 00:00:52,880
It is typically contiguous. So you can have autonomous systems, or you can have an organization

8
00:00:52,880 --> 00:00:59,200
that is so large that it has multiple sites, multiple locations on the internet, and then

9
00:00:59,200 --> 00:01:04,800
most likely you have different autonomous system numbers. Each autonomous system is assigned an

10
00:01:04,800 --> 00:01:10,320
official number. You cannot just pop up on the internet and become an autonomous system. You

11
00:01:10,320 --> 00:01:14,160
have to register and apply for a number. You can be assigned a unique number.

12
00:01:14,160 --> 00:01:27,840
Okay. Various days. OSI, standard vertical stack that you probably would have seen in the network's

13
00:01:27,840 --> 00:01:35,440
power source. Seven layers. It does not correspond to reality. At least not in the upper layer. The lower

14
00:01:35,440 --> 00:01:41,840
core layers kind of do, because here we have the actual physical transmission, right? Some kind of

15
00:01:41,840 --> 00:01:49,920
wireless or wired, not basically that, even pigeons, right? Whatever. And then on top of that,

16
00:01:49,920 --> 00:01:57,440
you have a data layer, something that's called MAC layer, media access control, right? MAC layer. And above that,

17
00:01:57,440 --> 00:02:09,280
you have a network layer, where in our case, IP lives. And then in a transport layer, you have things like

18
00:02:09,280 --> 00:02:17,760
TCP, UDP, ICMP, and what else? Some kind of niche protocols. And then on top of that, you have things

19
00:02:17,760 --> 00:02:26,720
like SSL and CLS, and HTTP, etc. And this has RPC, while this is a bit outdated, but remote procedure

20
00:02:26,720 --> 00:02:33,120
calls that used to be implemented. This still is implemented on top of the transport layer. And then

21
00:02:33,120 --> 00:02:39,760
the rest is like session and presentation layer. There's like a bit less clarity, how to map that.

22
00:02:39,760 --> 00:02:53,200
So we call the data format. So your application will be passing the data forward to the transport layer.

23
00:02:55,200 --> 00:03:03,680
The data that an application passes to the transport layer can be just a blob, okay? Some kind of blob,

24
00:03:03,680 --> 00:03:10,080
we don't care how long it is, as long as it fits in the address space of a computer, right? Available

25
00:03:10,080 --> 00:03:15,760
program memory, some kind of buffer. So we don't say how long this is. Let's just assume it can be

26
00:03:15,760 --> 00:03:24,320
arbitrarily long. And the transport layer, typically today, what happens is, if it goes to a DCP, right?

27
00:03:24,320 --> 00:03:31,920
So a DCP is by far the prevalent protocol for transport layer, not the only one. But a DCP layer,

28
00:03:31,920 --> 00:03:39,680
what happens is DCP will look at the application data and say, okay, I am aware, I, DCP, I'm aware

29
00:03:40,720 --> 00:03:50,080
of the maximum transmission unit of the lower layers. I know exactly what is the maximum packet size.

30
00:03:51,200 --> 00:03:58,560
So because it is aware, it will chop that application data into chunks or segments,

31
00:03:58,560 --> 00:04:06,960
and then slap a TCP header in front of each one of them. A unique DCP header that will be unique,

32
00:04:06,960 --> 00:04:11,520
because remember, DCP header has all kinds of things. But one of the things you should remember,

33
00:04:11,520 --> 00:04:20,400
we talked about it, is data offset. Remember offset field? So for a given DCP connection, right, there will be

34
00:04:20,400 --> 00:04:28,560
different offsets when the application data is split out. But the source, destination, port numbers

35
00:04:28,560 --> 00:04:36,960
in those PCP headers in multiple segments will be the same. So the offset field is very important,

36
00:04:37,600 --> 00:04:42,160
and it's interesting because it serves as both the actual offset into the data,

37
00:04:42,160 --> 00:04:52,320
but it also serves as kind of a sequencing. Except it's not incremented by one, it's incremented by the size of each segment.

38
00:04:53,520 --> 00:05:03,040
So at any time, a DCP connection, the offset represents the number of bytes, of data bytes,

39
00:05:03,040 --> 00:05:17,040
in that direction. It's unidirectional, which means that Alice is talking to Bob. This is going to reflect

40
00:05:17,600 --> 00:05:28,480
the number of bytes that Alice sent to Bob thus far on this DCP connection. Okay? Bob Mason, more or

41
00:05:28,480 --> 00:05:38,240
less, it has its own offset in Bob to Alice direction. Okay? At the network player, each DCP segment,

42
00:05:39,040 --> 00:05:49,440
each DCP segment, will likely not get fractured. Okay? Because the DCP is aware that an IP header will be

43
00:05:49,440 --> 00:05:57,120
slapsed in front of you. So it accommodates that. It takes it into account. Okay? So now we have an IP

44
00:05:57,120 --> 00:06:02,400
IP header, a DCP header, followed by data. That is faster than the data lake layer. In this case,

45
00:06:02,400 --> 00:06:13,200
it's Ethernet. Now Ethernet works over wires, twisted there, over fiber, it works over Ether.

46
00:06:15,440 --> 00:06:21,680
Right? But it stands in, so that's physical layer, right? That's physical layer. What physical

47
00:06:21,680 --> 00:06:30,080
media uses? But the MAC layer, okay, data lake layer, there's a standard, Ethernet standard,

48
00:06:30,080 --> 00:06:36,240
that says exactly how packets are formatted. So the network layer, IP packet comes in,

49
00:06:37,040 --> 00:06:44,400
and Ethernet header is added, and then Ethernet tree lays again. So the packet essentially encapsulates

50
00:06:44,400 --> 00:06:51,920
this. Okay? If you are using any secure, or if your Wi-Fi, you know, usually wired does not,

51
00:06:51,920 --> 00:06:59,120
but if your Wi-Fi is using some security measures, like WAP, WAP, or whatever the heck they're using,

52
00:06:59,120 --> 00:07:08,080
WFPA, that will be taken to our pair, at that layer. Okay? So there will be additional shields,

53
00:07:08,080 --> 00:07:12,720
additional subtenants here. But what I'm showing you here is just without any security, right?

54
00:07:12,720 --> 00:07:19,440
If time permits, at some point I will talk to you about wireless security, right? That usually happens

55
00:07:19,440 --> 00:07:34,640
at this layer, not above. Now, if you listen to prior lectures carefully, you remember me spending time

56
00:07:34,640 --> 00:07:43,040
on fragmentation, right? And you may ask, why did I spend all this time talking about fragmentation,

57
00:07:43,040 --> 00:07:48,000
and I just informed you that fragmentation actually does not have an IP layer, right? Yeah.

58
00:07:49,600 --> 00:08:00,160
Contradiction? Yes. Except that TCP is not the only transport layer protocol. Other transport layer

59
00:08:00,160 --> 00:08:09,760
protocols are allowed not to be as complicated and to pass to IP anyway. In fact, TCP is just very

60
00:08:09,760 --> 00:08:16,240
considerate and nice this way. One of the reasons it is, is because it doesn't want to deal with IP

61
00:08:16,240 --> 00:08:23,680
fragmentation. It has its own fragmentation to use. Do you see? So it wants things to go fast.

62
00:08:23,680 --> 00:08:30,800
It optimizes through. It optimizes through. Other protocols do not have to do. How many of you are

63
00:08:30,800 --> 00:08:40,000
familiar with the Linux kernel or any Linux kernel? A few of you. Did you know that there's something

64
00:08:40,000 --> 00:08:50,960
called raw sockets? Anybody knew that? Good. You can actually have an application, write an application

65
00:08:50,960 --> 00:08:59,600
that uses IP directly. You do not have to go through some session layer and then transport layer. You can

66
00:08:59,600 --> 00:09:07,760
actually write an application. They just directly accesses IP. In which case your application is its own

67
00:09:07,760 --> 00:09:17,680
is your own transport layer. Okay? Stunted, crazy, silly, maybe, yes, but it's allowed. Just FYI,

68
00:09:19,040 --> 00:09:27,200
many open unisex versions allow you to also write raw ethernet. That is, if your application

69
00:09:28,400 --> 00:09:33,040
if your kernel configuration lets you do it, you can actually open a raw ethernet socket and send

70
00:09:33,040 --> 00:09:39,360
directly infinite packets. In which case your own network layer. But these packets will not go

71
00:09:40,000 --> 00:09:48,240
past the first router. You see what I'm saying? Okay? Unless you re-implement IP and DCP and whatever

72
00:09:48,240 --> 00:09:57,120
else, right? So that's why this is not a contradiction, right? For example, UDP, which is another transport

73
00:09:57,120 --> 00:10:06,480
protocol, can hand over to IP a packet that is very big, and then IP is N24, will fragment. IPv6 will

74
00:10:06,480 --> 00:10:17,840
barge. Okay, let's give you an error. Right, so TCP requires the segment to break data into segments,

75
00:10:17,840 --> 00:10:23,280
and the receiver must reassemble segments. And because TCP is a connection-oriented

76
00:10:23,280 --> 00:10:29,920
protocol, right? With explicit establishment and tear down a connection, there's an acknowledgement for

77
00:10:29,920 --> 00:10:40,640
every packet. Well, there's an acknowledgement, okay? And lost packets, when the lost packets are

78
00:10:42,720 --> 00:10:47,760
detected or there's no acknowledgement coming through the center for a particular system, it has to

79
00:10:47,760 --> 00:10:54,800
re-transpense. And one of the more important things in TCP is the maintenance of what's called

80
00:10:54,800 --> 00:11:02,720
receiver window. Does everybody know what that is? So, normally, when you send segments one,

81
00:11:02,720 --> 00:11:08,160
segment two, segment three, segment four, you expect, normally, to receive them in the same sequence.

82
00:11:08,160 --> 00:11:18,640
But what if segment two gets lost? What if some router modifies a bit in segment two, and when it is

83
00:11:18,640 --> 00:11:25,680
received, it is incorrect. So, it's from away. So, it's essentially not being received. Or maybe it gets

84
00:11:25,680 --> 00:11:35,040
sent by a different route and gets stuck somewhere. So, that allows, so TCP handles this and allows the

85
00:11:35,040 --> 00:11:43,760
receiver to receive packets or segments that are not in order. And so, instead of expecting a window

86
00:11:43,760 --> 00:11:49,680
of size zero, meaning I receive packets one, two, three, the next one is four, right? It says, oh,

87
00:11:49,680 --> 00:11:57,520
I receive packets one, two, five, but I'm okay with receiving three, four, or six, okay? So, that's called

88
00:11:57,520 --> 00:12:03,120
the size of the window. The size of the window is dynamic based on the characteristics of the network

89
00:12:03,120 --> 00:12:07,840
of traffic, right? It has to do with, like, congestion on the internet, okay? And many other

90
00:12:07,840 --> 00:12:19,440
factors that influence the size of the TCP window. Now, IP is much simpler. Recall, it says vertical,

91
00:12:19,440 --> 00:12:25,680
but it's actually not a vertical. It is a packet format. It is an extreverse. Every packet is on its own.

92
00:12:25,680 --> 00:12:37,680
So, it uses either prefixes off or exact destination addresses for routing. Okay? What am I saying?

93
00:12:38,960 --> 00:12:48,160
When the packet arrives at a router, IP back, the router's main job is to take the destination of

94
00:12:48,160 --> 00:12:57,120
that packet and look that up in its routing table, FIB, forwarding information dates. That's a weird term.

95
00:12:57,120 --> 00:13:04,400
It's really a routing table. And it can be huge, huge, huge, especially for a backbone router.

96
00:13:06,000 --> 00:13:14,400
So, how does it look it up? Well, it's not the exact match. It's possible that the destination

97
00:13:14,400 --> 00:13:19,440
IP address is exactly present in the routing table. It says to this, for this destination address,

98
00:13:19,440 --> 00:13:28,000
go there. But most likely it's not like that. What it says is the prefix for that destination address

99
00:13:28,000 --> 00:13:35,120
is over there. So, you see this example destination here. So, it could be that the routing table can

100
00:13:35,120 --> 00:13:41,120
trace an entry for exactly this, or it could be that it contains an entry for 171, 64, 66.

101
00:13:41,120 --> 00:13:49,920
That's called a prefix. That's called a prefix. It's one example. 171 is also a prefix. That's the

102
00:13:49,920 --> 00:13:57,360
shorter prefix. So, what I think I'm going to do is it looks for the longest prefix, right? The most

103
00:13:57,360 --> 00:14:05,520
exact match possible. And that is the entry when it finds the entry with the longest prefix. It says,

104
00:14:05,520 --> 00:14:13,520
okay, what is the next entry? In that entry, you have all kinds of stuff, including which interface

105
00:14:13,520 --> 00:14:21,040
to forward it on next. What is the next stop for this package? It doesn't know the actual route,

106
00:14:21,040 --> 00:14:27,520
right? IP routers do not know the actual route this package will take to the destination. It's just

107
00:14:27,520 --> 00:14:41,920
the destination and the next stop. Okay. If no match is found, what's supposed to happen but doesn't

108
00:14:41,920 --> 00:14:50,400
always happen is an ICMP destination and reachable packet is generated back to the source.

109
00:14:50,400 --> 00:14:58,960
source. Okay? So, whatever you see in your browser post-unreachable, right? You're trying to load

110
00:14:58,960 --> 00:15:09,280
something unreachable, that's essentially what happens. Okay. So, long as we can match,

111
00:15:09,280 --> 00:15:15,120
of course, there are usually several hops, often more than several. If you actually do a trace route,

112
00:15:15,120 --> 00:15:27,280
you will see if you do a trace route and then give an IP address or trace out host names,

113
00:15:27,280 --> 00:15:36,560
you will actually see in excruciating detail the hops, the IP addresses of the hops, your packet takes

114
00:15:36,560 --> 00:15:53,120
from here to there. Okay. Now, the hops and ASs are different things, right? A hop is a physical

115
00:15:53,120 --> 00:16:00,080
hop from IP router to IP router or from IP host to the router or from IP router to the destination host,

116
00:16:01,040 --> 00:16:09,040
right? All these are physical hops. Now, there are AS hops, which means how many ASs you go through

117
00:16:09,040 --> 00:16:15,680
on the way to the destination. Well, every AS typically has at least a hop within it, right?

118
00:16:16,400 --> 00:16:21,200
So, you enter an AS through what's called an entry router and you exit through an exit router.

119
00:16:21,200 --> 00:16:26,240
They may be connected directly or there may be intermediate hops within the AS.

120
00:16:26,240 --> 00:16:35,120
So, trace route should tell you that, but some ASs do not expose their internal structure

121
00:16:35,920 --> 00:16:39,520
and they will not reply to this, will not respect the trace route.

122
00:16:41,280 --> 00:16:45,520
So, it's not guaranteed. Typically, what you see in trace route is correct, but it's not complete.

123
00:16:45,520 --> 00:17:01,440
All right. Any questions so far? ICMP is the protocol I mentioned, right? Instead of for plumbing on the

124
00:17:01,440 --> 00:17:09,200
internet, it's a very compact transport layer protocol that is used for exchanging maintenance

125
00:17:09,200 --> 00:17:13,920
messages. This is actually a protocol, not a packet format. I mean, it has packet formats,

126
00:17:13,920 --> 00:17:20,080
but it is a protocol meaning messages here are generated upon some events and they have mean.

127
00:17:21,840 --> 00:17:32,000
So, error reporting, congestion control, reachability, timing, etc. Okay? So, destination

128
00:17:32,000 --> 00:17:37,760
unreachable I already mentioned. Time exceeded. Oh, that's when TTL gets decremented to zero. Remember

129
00:17:37,760 --> 00:17:43,760
TTL and IP packet header? And this packet has been, yeah, usually set to 255. So, if something,

130
00:17:44,640 --> 00:17:50,720
if it reached zero, this packet has been looping around. Something is very wrong. Parameter problem,

131
00:17:50,720 --> 00:17:56,400
I'm not sure what the heck that is. Redirect to a better gateway means that, tells the previous gateway,

132
00:17:56,400 --> 00:18:01,680
your routing is messed up. You're sending it to be a packet, but there's a better place, better next

133
00:18:01,680 --> 00:18:08,560
hop of that packet than me. Reachability test, that's the one, echo reply, that's the one that trace

134
00:18:08,560 --> 00:18:19,040
round uses. And timestamp reply, this is also for when you put a timestamp option in an IP option field.

135
00:18:19,040 --> 00:18:31,120
TMI. Security issues. Many security issues because neither TCP nor IP were natively designed for

136
00:18:31,120 --> 00:18:38,080
security. Remember, it was all designed in a very, uh, prehistoric, friendly world, where nobody wanted

137
00:18:38,080 --> 00:18:45,440
to hurt each other, steal each other's information. So, uh, packets go by untrusted hosts, our routers,

138
00:18:45,440 --> 00:18:53,120
uh, sniff, and maybe log packets. And sometimes, for good reason, organizations, uh, companies will

139
00:18:53,120 --> 00:19:01,280
often log all IP traffic that comes from inside out and also inside in for all kinds of, uh, auditing

140
00:19:01,280 --> 00:19:06,960
purposes. Like if shit hits the fan and things go wrong, they need to investigate and figure out, ah,

141
00:19:06,960 --> 00:19:13,200
how exactly sort of forensically figure out what happened, right? Where did the malware come in? Where

142
00:19:13,200 --> 00:19:18,240
did the phishing come in? Where did the routing update, you know, fake routing that they can be

143
00:19:18,240 --> 00:19:24,480
so they need to do this. And so this logging can, or sniff, sniffing can happen for benign reasons,

144
00:19:24,480 --> 00:19:30,880
or it can happen for non, for malicious reasons. IP addresses, as, as, as we talked about, are public.

145
00:19:30,880 --> 00:19:36,880
They're not hidden, um, unless you're using IPsec, but even with IPsec, right, the outermost IP

146
00:19:36,880 --> 00:19:46,560
here is visible. And it often provides some information. Uh, TCP connection. So IP is difficult

147
00:19:46,560 --> 00:19:56,160
to abuse by itself because it's not a protocol, but TCP is a protocol. And you saw the state diagram

148
00:19:56,160 --> 00:20:01,760
that I hope impressed the heck out of you, right? There are actually courses out there. When I was in

149
00:20:01,760 --> 00:20:07,760
grad school, we had to memorize the freaking TCP diagram and answer, you know, final questions

150
00:20:07,760 --> 00:20:14,880
that you should feel, you should feel lucky. I mean, pretty much everybody failed that. But,

151
00:20:15,680 --> 00:20:24,080
but it was, it was rough. Um, TCP requires state, right? Because the connection is this connection

152
00:20:24,080 --> 00:20:28,240
oriented protocol and every connection oriented protocol on the face of this earth requires state

153
00:20:28,240 --> 00:20:33,440
here and there at the source and the destination or whatever the connection endpoints, right?

154
00:20:34,160 --> 00:20:42,000
And that state isn't free. Depending on how your, uh, network protocol stack is implemented within

155
00:20:42,000 --> 00:20:50,400
the kernel, outside the kernel, it is consuming memory and resources. There is a whole course discussion

156
00:20:50,400 --> 00:20:54,000
of whether you should put, you know, an operating system should keep the network

157
00:20:54,000 --> 00:21:00,240
stack inside the kernel or outside the kernel. Outside the kernel makes the kernel nicer, smaller,

158
00:21:01,200 --> 00:21:09,840
easier to find bugs, et cetera, et cetera, faster maybe, but putting it inside makes networking faster.

159
00:21:11,200 --> 00:21:16,720
Because if the, if the networking stack runs outside kernel space, you have to switch into the kernel

160
00:21:16,720 --> 00:21:23,760
often, right? Because there's some still controls that need to take place. Anyway, um, state is important. And

161
00:21:23,760 --> 00:21:29,680
there are attacks and so attacks on that state. And we will see one very impressive example called

162
00:21:29,680 --> 00:21:39,040
SynthFlight. Also, TCP state, the state that is maintained at both ends of a connection is not secret by

163
00:21:39,040 --> 00:21:47,040
nature. And because it's not secret, it can be sometimes easily guessed. And if you guess that state

164
00:21:47,040 --> 00:21:53,520
correctly, you can manipulate the connection by injecting traffic into it. Even from my outside,

165
00:21:53,520 --> 00:22:00,400
from far away, from far away, you can inject traffic into it. And you can even close a connection,

166
00:22:01,840 --> 00:22:13,440
which is kind of a nifty denial of service attack. Okay, so sniffing is not so impressive, right? So

167
00:22:13,440 --> 00:22:23,920
what they have to do just sniff. But years ago, back in the 90s, early 2000s, there was still a lot of

168
00:22:23,920 --> 00:22:33,280
alignment, there were most implementations of these commands like ftp, telnet, rcp, you may have run into

169
00:22:33,280 --> 00:22:39,360
these commands. And they still exist in many Unix versions, right? FTP file transfer, telnet, remote

170
00:22:39,360 --> 00:22:47,680
login, rcp, remote copy, RSH, remote shell. Okay, these commands required passwords, right? But they

171
00:22:47,680 --> 00:22:55,280
sent them in the clear. Because remember, the world was friendly. Yes, you have to have a password that if you

172
00:22:55,280 --> 00:22:59,760
sniffed on those packets that were sent back and forth, and you sniffed on them in the beginning of a

173
00:22:59,760 --> 00:23:03,840
connection, you would actually get a clear text password. Now, why am I telling you this? This is

174
00:23:03,840 --> 00:23:08,560
prehistory, right? Well, the truth is, prehistory is not actually that much of a prehistory. Because

175
00:23:09,280 --> 00:23:15,360
out there in the real world today, there are still Windows 3.0 implementations running.

176
00:23:17,040 --> 00:23:23,200
Yes, legacy, like from the 90s, there are many places, especially in industrial control,

177
00:23:23,200 --> 00:23:31,680
where really obsolete operating systems are used. Why? Because some software is written

178
00:23:31,680 --> 00:23:35,520
to take advantage of those operating system features, and nobody knows because the people

179
00:23:35,520 --> 00:23:42,240
who wrote it probably are dead now, okay? Or in a retirement home and demented, or doing something

180
00:23:42,240 --> 00:23:48,640
else, and nobody learned how to program on Windows 3.0 because it's so old. You get the point? Just like

181
00:23:48,640 --> 00:23:56,640
NASA and the federal government in general has gazillions of lines of code in various software

182
00:23:56,640 --> 00:24:06,080
installations that run COBOL. Maybe your grandparents know what COBOL is, if they were in the tech industry.

183
00:24:06,080 --> 00:24:13,200
But COBOL is a language from the 60s. Tons of code was written in COBOL, and a lot of it still remains.

184
00:24:13,200 --> 00:24:22,800
Because nobody knows COBOL programmers today earn big bucks. If they're alive. Anyway, so these,

185
00:24:22,800 --> 00:24:29,840
these things still out there. The other thing is that if you, the Ethernet itself, right?

186
00:24:31,600 --> 00:24:38,720
So I'm stepping down into the data link layer. Ethernet by itself has some very interesting features.

187
00:24:38,720 --> 00:24:44,080
Most Ethernet interfaces have a way of being put in what's called promiscuous mode.

188
00:24:45,040 --> 00:24:52,000
And this is how ethereal works and TCP dump, if you've used those pretty popular programs.

189
00:24:52,880 --> 00:24:59,520
They put the card in the, in the promiscuous, your card, the NIC, the network interface control module,

190
00:24:59,520 --> 00:25:05,120
into this promiscuous mode. And you basically receive all the packets sent on the second. So

191
00:25:05,120 --> 00:25:11,360
it means that if one of you does this with ethereal and TCP dump, you should be able to see everything

192
00:25:11,360 --> 00:25:16,320
that goes on here, maybe even outside, as long as the same access point is being used.

193
00:25:17,440 --> 00:25:22,560
Right? It's called an Ethernet segment, right? So you will hear all the packets on the Ethernet segment.

194
00:25:24,880 --> 00:25:27,520
So that's not very nice, but that's how it works.

195
00:25:28,400 --> 00:25:34,240
Now, if there's wireless security, like web, web, WPA, or something like that, plus there is IPsec,

196
00:25:34,240 --> 00:25:39,760
plus there is SSL, you won't get anything. But at the very least, you'll see who is communicating.

197
00:25:41,760 --> 00:25:43,840
You will also see how much they're communicating.

198
00:25:45,520 --> 00:25:49,760
Right? You will see, oh, a particular Ethernet MAC address is talking to the access point,

199
00:25:49,760 --> 00:25:54,960
and it's sending large chunks of stuff. Oh, maybe somebody is recording this lecture here.

200
00:25:56,400 --> 00:26:02,640
God forbid. Or they're not sending large chunks of stuff. Small chunks, they're receiving large

201
00:26:02,640 --> 00:26:08,080
chunks in regular fashion, like regularly. Ah, somebody here is using streaming video. Right?

202
00:26:09,920 --> 00:26:16,240
Or it will be sending small chunks of small Ethernet packets upwards and receiving kind of irregular

203
00:26:16,240 --> 00:26:22,960
size things back. Well, they're probably just browsing the web, right? So information is power.

204
00:26:27,200 --> 00:26:29,840
So one example of an

205
00:26:30,400 --> 00:26:37,600
Ethernet, sorry, of an attack that works on the Ethernet, but is actually not an Ethernet attack,

206
00:26:37,600 --> 00:26:44,480
is the SMRF. Don't try this. You may actually find a few places where this would work. It shouldn't

207
00:26:44,480 --> 00:26:52,480
work today because of some remedial measures, but the SMRF attack basically works like this. You have,

208
00:26:52,480 --> 00:26:58,320
you see, these hosts, these computers are on the same Ethernet segment. It doesn't matter if this is

209
00:26:58,320 --> 00:27:03,680
wired about wires, okay? Okay, so they're on the same segment, and they're controlled by that router.

210
00:27:05,280 --> 00:27:09,360
So if they talk to each other, they talk directly, but if they talk to anybody outside,

211
00:27:09,360 --> 00:27:16,960
they go through the router, okay? Kind of like we do go through the access point here. Okay, so

212
00:27:16,960 --> 00:27:24,240
suppose the adversary has a victim, some computer, right? Some phone, a computer or tablet or something

213
00:27:24,240 --> 00:27:31,920
with an IP address, okay? That victim is somewhere else. Could be close nearby, could be far away.

214
00:27:31,920 --> 00:27:40,480
Okay, so what the adversary does is it generates an ICMP packet, okay? ECHO request with ECHO request

215
00:27:40,480 --> 00:27:48,240
back. And according to the protocol specs, when a host receives an ICMP ECHO request,

216
00:27:48,240 --> 00:27:55,680
it's supposed to reply with ICMP ECHO reply. Nothing, nothing bad about that,

217
00:27:55,680 --> 00:28:04,240
but if you generate this packet from outside, right? That Ethernet segment, it goes for the router,

218
00:28:04,240 --> 00:28:10,560
and then, as long as you put the destination broadcast address, and by the way, there is such

219
00:28:10,560 --> 00:28:17,520
a thing, right? 255, 255, 255, 255 means everybody's supposed to receive this.

220
00:28:17,520 --> 00:28:26,080
Everybody will receive it and dutifully generate an ECHO reply. Now, my silly picture has three

221
00:28:27,360 --> 00:28:35,440
hosts on that set. But what if there is a 10,000 host on that set? Two things will happen.

222
00:28:36,800 --> 00:28:44,160
One is the router will get a bit clogged. Maybe not so much. But that victim is going to get overwhelmed,

223
00:28:44,160 --> 00:28:50,960
because especially if the adversary generates at nearly the same time a bunch of those ECHO requests

224
00:28:50,960 --> 00:28:58,000
to different Ethernet segments out there, and everyone will reply to the poor victim.

225
00:29:00,480 --> 00:29:07,440
Yes. The adversary also, you see, and the source, as the source does not put his IP address,

226
00:29:07,440 --> 00:29:14,560
puts the victim's IP address in red. I think that IP address is unauthenticated.

227
00:29:16,160 --> 00:29:21,840
So the router will pass it, all the hosts on that segment will receive it, and dutifully reply.

228
00:29:24,240 --> 00:29:29,680
Once you know the problem, it's easy to fix, right? But the problem existed for a while.

229
00:29:29,680 --> 00:29:39,200
You see this problem? Don't turn off broadcast. Maybe that is a bit heavy-handed,

230
00:29:39,840 --> 00:29:44,400
because there may be legitimate reasons to use broadcast within here, within this segment.

231
00:29:44,400 --> 00:29:50,240
But what you do instead, you say, fill the router. You should not allow external packets

232
00:29:50,240 --> 00:30:00,240
address to the broadcast address. Right? Simple. You cannot authenticate the source that victims address.

233
00:30:00,240 --> 00:30:05,440
You don't know if it's true or not. But what you can do is say, broadcast can only be on the inside.

234
00:30:06,400 --> 00:30:12,160
The router does not pass any any broadcast address pattern. Just drop it. That's it.

235
00:30:12,160 --> 00:30:20,960
Ring of death. Even that might still exist. This is very old, but that might still exist somewhere.

236
00:30:20,960 --> 00:30:28,080
Because if you have an old, like, I think 3.0 or 3.1 Windows machine, there was a bug in the kernel.

237
00:30:28,720 --> 00:30:36,560
And what if, because, of course, IP was inside the kernel, so an ICMP packet with a payload over 64k was received,

238
00:30:36,560 --> 00:30:45,440
bam, crashed. It's not supposed to send IP packets over 64k, but if somebody does, there was no check.

239
00:30:46,960 --> 00:30:53,360
So memory was overwritten. Some important stuff was overwritten as a result. Right? Because what does

240
00:30:53,360 --> 00:30:58,880
it mean received? You receive a packet and you have to copy it into some buffer, right? Yeah, you all

241
00:30:58,880 --> 00:31:04,880
programmed at one point in your life, right? You have to copy it into some freaking buffer. But if the buffer is

242
00:31:04,880 --> 00:31:10,800
set hard-coded 64k, and you receive a packet of 128k, what's going to happen if this bug is present,

243
00:31:10,800 --> 00:31:16,480
if you don't check the boundaries? You're going to keep writing. And the extra 64k are going to

244
00:31:16,480 --> 00:31:25,360
overwrite something damn important. Boom. Okay, it's easy to fix once you know.

245
00:31:25,360 --> 00:31:35,680
Right. Then there's teardrop. They all have cutesy names, right? Teardrop.

246
00:31:38,800 --> 00:31:46,880
Remember we talked about overlapping fragments, right? So that's one. Except this is for TCP, not for IP.

247
00:31:46,880 --> 00:31:53,200
Right? So you can have this overlapping in IP. You have fragmentation offset, remember? That's for the

248
00:31:53,200 --> 00:32:00,400
same packet. While the same thing, similar thing happens in TCP, except remember TCP sends segments.

249
00:32:01,920 --> 00:32:06,560
And every segment has an offset field. It's not a fragmentation. It's just offset into the

250
00:32:06,560 --> 00:32:15,280
conversation, right? And if you send overlapping offsets, then bad things would happen. Right? So the

251
00:32:15,280 --> 00:32:20,400
attacker says offset filter overlapping values. And then when you reassemble, remember what happens

252
00:32:20,400 --> 00:32:25,840
when you reassemble things with overlapping values, you wind up also overwriting stuff. So it would crash.

253
00:32:27,360 --> 00:32:29,440
Again, easy to fix once you know.

254
00:32:33,600 --> 00:32:39,760
I love this one. I don't know why it's called land. But there was also an older version of Windows,

255
00:32:39,760 --> 00:32:46,960
again, I think 3.0. Where if you send an IP packet with a source address and a destination address the

256
00:32:46,960 --> 00:32:53,440
same, meaning itself. So it's like saying, oh, the packet comes from the outside, but the source

257
00:32:53,440 --> 00:32:58,960
address is this host. And the destination address is this host. And the port numbers are the same.

258
00:32:59,680 --> 00:33:04,400
It will just, like, lock the CPU. Go into, like, obviously an endless loop.

259
00:33:04,400 --> 00:33:13,440
So easy to fix. You shouldn't be receiving packets with your address as the source. Hey, right?

260
00:33:18,960 --> 00:33:28,640
Uh, okay. Reminded by TCP handshake. We're not down to TCP. Yeah. Three-way handshake. Three packets.

261
00:33:29,280 --> 00:33:35,120
So not, like, one and a half round check, really. Now remember, client starts the connection, right?

262
00:33:36,080 --> 00:33:40,160
Client starts the connection because client has something to say to the server. Now here,

263
00:33:40,160 --> 00:33:44,160
the server doesn't have to be a web server, right? We're talking about just a connection.

264
00:33:47,200 --> 00:33:54,640
So just think more broadly than just a web. So the client starts with the sin packet, the sinc.

265
00:33:54,640 --> 00:34:06,000
The server, when it receives the packet, says, oh, ah, new connection request. Wonderful. Let me allocate

266
00:34:06,000 --> 00:34:13,840
some state. Let me reserve a little space in my table. I have a stable of open connections. Let me

267
00:34:13,840 --> 00:34:20,000
create a new entry. Let me put the source address of this packet, meaning the client's source,

268
00:34:20,000 --> 00:34:24,480
IP address there. Let me put the fact that the connection is ongoing. It's not established,

269
00:34:25,280 --> 00:34:34,880
okay? And sometimes, many times, spawn a thread. That is, threading is such a cool paradigm, right?

270
00:34:35,840 --> 00:34:43,520
Everybody loves threading, right? So spawn a new thread for that connection and go on to another thing,

271
00:34:43,520 --> 00:34:50,480
okay? You don't want to sit there, right? And be dumb, you know, to just like receive a packet

272
00:34:51,520 --> 00:34:58,320
and then send a packet and then wait, right? And lock up and nothing happens. Now, you spawn a thread,

273
00:34:58,320 --> 00:35:04,080
that thread corresponds to this connection that is not yet established. And then you go on to do other

274
00:35:04,080 --> 00:35:12,080
things, right? Like receiving more connection requests, okay? Makes sense. As soon as you spawn a

275
00:35:12,080 --> 00:35:17,920
thread reply, the server replies with its, as the protocol dictates with sin s, which is the server

276
00:35:17,920 --> 00:35:24,960
sin, and the act saying, hey, here's client, here's your act. I acknowledge having received your connection

277
00:35:24,960 --> 00:35:33,200
request. The client is then supposed to reply with act to the server act s. And at this point,

278
00:35:34,320 --> 00:35:41,040
the connection is established, okay? Remember with the firewall lecture, we had this like one example

279
00:35:41,040 --> 00:35:47,440
where there was a table and it's a connection like established. So it wasn't in the being

280
00:35:47,440 --> 00:35:52,560
established, it's already established, right? So at this point, connection is established on both hands.

281
00:35:53,600 --> 00:35:57,040
That's the normal way of doing things. That's how it's supposed to happen.

282
00:35:57,040 --> 00:36:08,160
Now here's a sin-flying attack. The adversary doesn't have to play by the rules, right? That's why it's the

283
00:36:08,160 --> 00:36:18,320
adversary. The adversary generates in quick succession, or almost simultaneous, a large number of sin packets.

284
00:36:18,320 --> 00:36:24,880
This is the opening salvo, right? The first packet in the TCP connection is a sin from the client.

285
00:36:24,880 --> 00:36:31,520
The second packet. Bam, bam, bam, bam, bam, bam. For every stupid sin, the server says,

286
00:36:32,160 --> 00:36:38,640
how nice, let me open a, let me spawn a thread, dedicate some buffer space or table space.

287
00:36:39,840 --> 00:36:45,840
Do you see what's happening? This grows faster than a mushroom under the brain, right?

288
00:36:46,560 --> 00:36:52,720
It expands immediately, like the consumption. Many threads get created, right, at almost the same time.

289
00:36:53,440 --> 00:37:02,400
The server chokes. Runs out of space. No more space. No more TCP connection. Including no more legitimate

290
00:37:02,400 --> 00:37:08,720
TCP connection. Do you see the point? It's not that necessarily, maybe the, maybe the adversary's

291
00:37:08,720 --> 00:37:13,680
goal is to just bring down the server. Or maybe the adversary's goal is to prevent legitimate TCP

292
00:37:13,680 --> 00:37:22,480
connection. Same effect. Top problem.

293
00:37:26,560 --> 00:37:32,960
So, it costs nothing for the attacker to do this. Also, my silly example on the previous slide showed

294
00:37:32,960 --> 00:37:39,040
one little red devil. One attacker, right? I'll let it fool you. It could be one attacker that controls

295
00:37:39,040 --> 00:37:46,400
multiple zombies around the internet. Right? A botnet. Every member of that botnet could generate

296
00:37:46,960 --> 00:37:58,240
that kind of a sin storm. Get the idea? The combination. One zombie, eh. A million zombies? The server is dead.

297
00:37:58,240 --> 00:38:05,920
It's dead. Plus, traffic gets congested, right? So, especially nice thing about controlling a zombie botnet

298
00:38:05,920 --> 00:38:12,960
is that zombies, ideally, are distributed well. Zombies everywhere in the world, they control them.

299
00:38:12,960 --> 00:38:19,040
On command from the command and control center, they start generating these sins to the victim.

300
00:38:20,400 --> 00:38:26,640
What happens is a funnel effect. Because the zombies are distributed at the source near them, nothing bad

301
00:38:26,640 --> 00:38:33,920
happens. But as they get closer to the victim, right, the funnel takes place. The traffic gets more

302
00:38:34,480 --> 00:38:41,120
concentrated. Higher volume, yes? You see that? Like, think about the victim's ISP. All of a sudden,

303
00:38:41,120 --> 00:38:45,280
the victim's ISP is going to get more concentrated. So, not only the victim is going to get screwed, but

304
00:38:46,880 --> 00:38:53,120
nodes next to you, IS. The ISP IS is going to get congested. So, it's going to affect more than just the victim.

305
00:38:55,120 --> 00:39:04,720
Okay. So, you can read this, right? The point of this attack is a classical example of a symmetry.

306
00:39:04,720 --> 00:39:08,000
Why a symmetry?

307
00:39:08,960 --> 00:39:16,800
Very clear, no? It costs nothing to generate a sin. It costs nothing to generate a thousand sins.

308
00:39:17,840 --> 00:39:25,040
For a client. But for a server, there's an investment. It's asymmetric. It has to create

309
00:39:25,760 --> 00:39:31,120
state, right? Allocate memory. Spawn a thread. Even you say, oh, why didn't you spawn a thread?

310
00:39:31,120 --> 00:39:35,440
There are other paradigms you could use. Yeah, yeah, yeah, yeah. Sure. Spawning a thread is not

311
00:39:35,440 --> 00:39:40,080
required. But even if we weren't spawning a thread and using a different paradigm,

312
00:39:40,960 --> 00:39:47,040
we'd still have to allocate space. We'd still have to have a new connection. Something to remember about

313
00:39:47,040 --> 00:39:55,440
this, you know, not yet established connection, yeah? That's the asymmetry. Have you seen examples of

314
00:39:55,440 --> 00:40:03,120
this before? Anybody? Asymmetry. In attacks.

315
00:40:07,520 --> 00:40:14,800
Hell, most of you were born just probably after 9-11. 9-11, that horrific attack at the World

316
00:40:14,800 --> 00:40:22,800
Trade Center was an example of asymmetry. Over 3,000 people died, two skyscrapers were destroyed,

317
00:40:22,800 --> 00:40:29,280
a plane full of hijackers and innocent passengers flew into the building. That's an asymmetric attack.

318
00:40:31,440 --> 00:40:37,760
A guerrilla, terrorist, freedom fighter, call it whatever, with an RPG taking down a helicopter

319
00:40:39,040 --> 00:40:47,520
is an asymmetric attack. 9-11, it costs very little. You can probably buy an RPG, you know,

320
00:40:47,520 --> 00:40:55,200
across the border for a thousand dollars. Cheaper if you buy in bulk. A helicopter costs a gazillion

321
00:40:55,200 --> 00:41:02,960
dollars. 100, 140 million dollars. You bring down a helicopter with an RPG, that's a symmetric attack.

322
00:41:03,920 --> 00:41:11,840
Okay? Sorry to make this automatic. You get the idea. Asymmetry. It's unfortunate, but that's how it is.

323
00:41:11,840 --> 00:41:18,560
Now, what can we do about it? With a helicopter? Plants flying into buildings. I'm sorry, but there's not much we can do.

324
00:41:21,200 --> 00:41:22,480
But here we could do something.

325
00:41:28,080 --> 00:41:33,120
First, we examine the problem. What creates it? This sort of state allocation, asymmetric.

326
00:41:33,120 --> 00:41:39,040
Guys, the client is not dedicating anything, right? The client, a benign client in TCP, is supposed to allocate

327
00:41:39,040 --> 00:41:46,480
state before sending the SIM. He says, hey, I'm going to open a connection, right? So it creates a

328
00:41:46,480 --> 00:41:50,480
state space, and it's, you know, a table. It doesn't necessarily spawn a thread. It could.

329
00:41:52,560 --> 00:41:57,360
So it creates space, allocates memory, whatever, and then sends the sensee.

330
00:41:58,880 --> 00:42:02,960
But an adversary doesn't have to play with the rules. It doesn't need to allocate anything.

331
00:42:02,960 --> 00:42:11,280
It just can generate sensees at infinity. So he's not losing anything. Just sending packets.

332
00:42:12,800 --> 00:42:19,040
Now, one solution is cookies. And you think, oh, it's going to use web. No, no, it's not web,

333
00:42:19,040 --> 00:42:25,600
but it's similar to the web cookies. Okay? And the idea is, if instead of

334
00:42:25,600 --> 00:42:33,760
state allocation on the server side, will it receive that SIM from the client, if the server could

335
00:42:33,760 --> 00:42:43,840
somehow avoid creating state, then maybe it would solve this problem. And that's what this solution does.

336
00:42:43,840 --> 00:42:58,480
So here's a cute little solution. This is from about 15 years ago. It is, in fact, deployed. It is

337
00:42:58,480 --> 00:43:05,440
compatible with TCP. So you wouldn't know if it's deployed on a particular server, right? Unless you

338
00:43:05,440 --> 00:43:15,760
actually snoop on traffic. Okay? So the client starts with a sensee, right? Just like it does. We don't

339
00:43:15,760 --> 00:43:24,080
know if this client is good, bad, or ugly. Just a client. The server receives that sin. And remember,

340
00:43:24,080 --> 00:43:29,760
TCP server is over listening, right? That's why it's called the server. It's listening. So it gets the sensee,

341
00:43:29,760 --> 00:43:37,120
but that does not spawn a thread, does not create any state. That's the cool part. What it does,

342
00:43:37,120 --> 00:43:41,920
it replies with a sin as an axi, which is that second packet, the way it's supposed to,

343
00:43:41,920 --> 00:43:53,200
but it abuses or repurposes one of the field, which is a sequence number. Now the sequence number there

344
00:43:53,200 --> 00:44:02,400
in the reply, okay, is like, you get 16 bits, right? I think it's 16 bits. So what it does is,

345
00:44:02,400 --> 00:44:08,640
no, 32 bits, excuse me. And instead of leaving it be, to be whatever, zero, zero, right? Because

346
00:44:08,640 --> 00:44:16,160
at that point, no data has been, you know, sent back and forth. No real data, right? No application.

347
00:44:16,160 --> 00:44:23,360
It puts a certain value, and that value is a function. You see the function f of source address,

348
00:44:24,160 --> 00:44:30,160
destination, sorry, source port, destination address, destination port, course time,

349
00:44:30,960 --> 00:44:37,440
that's server's own time, right? Maybe rounded, not exactly like nanosecond precision, but let's say

350
00:44:37,440 --> 00:44:43,920
rounded to the nearest, I don't know, 10 milliseconds or something like that. That's server's own clock.

351
00:44:43,920 --> 00:44:53,360
And most importantly, server's secret, the key. A key that only server knows, so it's not shared with anyone.

352
00:44:55,280 --> 00:45:03,600
Okay, so it computes this 32-bit quantity and stuffs it into the sequence number field.

353
00:45:03,600 --> 00:45:14,960
The client receives the SNS-ACC packet and actually doesn't do anything. It's supposed to echo the sequence

354
00:45:14,960 --> 00:45:21,200
number back. That's according to the rules. It's supposed to echo that sequence. That's TCP rules. So the

355
00:45:21,200 --> 00:45:29,440
client does not know what's going on. He is not aware of any of this defense. So he just beautifully

356
00:45:29,440 --> 00:45:36,320
generates S for, you know, and includes the cookie, which he copies from the, is supposed to, as supposed

357
00:45:36,320 --> 00:45:46,320
to from the sequence number. Aha! So now the server says, okay, I am going to recompute the cookie.

358
00:45:47,040 --> 00:45:53,520
Why? Because you see, where does this source address, source port, destination, position report come from?

359
00:45:53,520 --> 00:46:02,400
They come from the IP packet. That is that first one, right? The SIN-C. Make sense?

360
00:46:04,320 --> 00:46:11,360
So that magenta field, right? It captures the source address, destination address of the original packet

361
00:46:11,920 --> 00:46:19,520
that opened the connection, the ones to open the connection. Now this S is also an IP packet, right?

362
00:46:19,520 --> 00:46:26,880
To the TCP, et cetera, et cetera. But the IP header, if it's an honest client, will contain the same IP

363
00:46:26,880 --> 00:46:31,760
source and the same IP destination and port numbers as it did in the original packet, yes?

364
00:46:33,600 --> 00:46:34,880
If the client is honest.

365
00:46:37,840 --> 00:46:45,520
So what the server does is says, ah, extracts the cookie and says, well, let me get the IP source,

366
00:46:45,520 --> 00:46:51,200
IP destination, the port numbers from this packet. I know my own secret.

367
00:46:52,960 --> 00:46:58,640
I know the course time, right? Because the time, not much time has passed, right?

368
00:47:00,960 --> 00:47:05,200
So it just recomputes the cookie and compares it to the one received in this packet.

369
00:47:06,000 --> 00:47:11,200
If the cookie values match, then it says connection is open, it creates a state.

370
00:47:11,200 --> 00:47:20,000
One second. If they don't match, throws it away. That's it. No big loss, right?

371
00:47:20,880 --> 00:47:22,160
As if it has never happened.

372
00:47:27,440 --> 00:47:30,400
Ah, good question, right? Okay, I was waiting for that.

373
00:47:30,400 --> 00:47:37,760
Why doesn't the attacker just play along? Tell me, why?

374
00:47:42,800 --> 00:47:44,880
Excellent exam question, but now it's gone.

375
00:47:50,880 --> 00:47:56,160
Why doesn't the attacker do the same thing? He knows what the, he knows the cookies look off.

376
00:47:56,160 --> 00:48:00,640
He can guess that the server is playing along, or he's playing this game. He can just do it.

377
00:48:02,080 --> 00:48:03,520
Pretend that, otherwise, sure.

378
00:48:06,480 --> 00:48:08,320
Any ideas? Any ideas at all?

379
00:48:10,400 --> 00:48:11,680
Why does this help at all?

380
00:48:11,680 --> 00:48:26,240
It helps because, remember the original attack, machine gun, bam, bam, bam, bam, right?

381
00:48:26,800 --> 00:48:29,200
One sin after another, bam, bam, bam, bam, bam.

382
00:48:30,800 --> 00:48:33,280
You can put different distance, source addresses in there, right?

383
00:48:33,280 --> 00:48:44,320
Yes? But now things have changed. The adversary before, let's for a second consider the adversary

384
00:48:44,320 --> 00:48:50,960
with a single host coming from a single computer, single IP group. The adversary would generate

385
00:48:50,960 --> 00:48:58,800
a large number of SIN requests, right? The initial packet, essentially machine gun the server,

386
00:48:58,800 --> 00:49:08,000
starting, you know, strangling itself to death. But now, in order for the server to delegate any

387
00:49:08,000 --> 00:49:20,160
resources, the client has to be there to receive the SIN ACK, right? Otherwise, server hasn't done anything.

388
00:49:20,160 --> 00:49:28,880
You get it? You get it? So, if the client did not receive the SIN ACK, he cannot generate ACK S,

389
00:49:29,760 --> 00:49:36,640
because he doesn't know the cookie. He doesn't know the cookie.

390
00:49:38,400 --> 00:49:41,680
One variation of this is to say, oh,

391
00:49:41,680 --> 00:49:52,160
the server, forget the cookies, let's not use cookies, but let's change TCP on the server so

392
00:49:52,160 --> 00:49:56,560
that server only allocates space after he receives an ACK S for the client.

393
00:49:58,720 --> 00:50:06,960
That's not a keyword. That's equally stupid as the original. You see why that is? Because if the server

394
00:50:06,960 --> 00:50:13,680
only allocates state after he receives ACK S without the cookie, generating ACK S is easy for any client,

395
00:50:15,840 --> 00:50:22,160
because it contains nothing secret. But the trick in this specific solution is that the cookie is

396
00:50:22,160 --> 00:50:28,880
computed with a secret known to the server, and no one can create valid cookies but the server.

397
00:50:28,880 --> 00:50:41,840
Now, somebody can snoop on a cookie. You can copy a cookie. But a cookie is only valid for a little bit of time.

398
00:50:43,040 --> 00:50:53,200
Okay? And if the source address doesn't match, cookie will be thrown away. So the whole idea is that it does not

399
00:50:53,200 --> 00:51:02,640
prevent the attack complicate. It makes it much harder for the adversary, because the adversary has to

400
00:51:02,640 --> 00:51:09,360
essentially complete that three-way handshake with the server for every fake connection it tries to establish.

401
00:51:10,480 --> 00:51:16,160
So yes, the server will still create the state and maybe spawn a threat, but it will only do it here,

402
00:51:16,160 --> 00:51:24,400
when this succeeds. Not there when it first receives the path, the original path. Questions?

403
00:51:33,200 --> 00:51:41,120
So, in reality, what is F? Because, okay, 32 bits is not really an encryption technique. So it's really

404
00:51:41,120 --> 00:51:47,440
more like a hash function. Okay? Because you kind of like stuff encryption in there. It's a hash function.

405
00:51:47,440 --> 00:51:55,120
Like the one with cryptographic hash. Typically, it's an AES, like AES-based hash or truncated SHA.

406
00:51:55,840 --> 00:52:04,960
Truncated means the server computes, recomputes the hash, which is like 128 bits, but only uses 32 of those.

407
00:52:04,960 --> 00:52:13,840
So the unfortunate thing about this approach is that it is restricted to 32 bits, which means that

408
00:52:13,840 --> 00:52:21,760
if somebody guesses a cookie, they can attack this technique. But guessing a cookie is probably

409
00:52:21,760 --> 00:52:25,360
the 1 over 2 to the 3 too. So it's not that easy to guess a cookie.

410
00:52:25,360 --> 00:52:36,560
Right. All right, this is just a verbal description. There's that, just take a second to read through

411
00:52:36,560 --> 00:52:38,720
this, but basically it's a word I already said.

412
00:52:46,080 --> 00:52:51,920
Right, so this will be, one thing to know is, of course, the IP address of the source may still be

413
00:52:51,920 --> 00:52:58,160
both. But that's not really a service for money. The server doesn't really care about it.

414
00:53:03,920 --> 00:53:11,600
Okay, a completely different approach, which uses no secrets, and is just a little bit kind of over

415
00:53:11,600 --> 00:53:18,080
the top, but works surprisingly well, it's called random deletion. And that is, it works like this.

416
00:53:18,080 --> 00:53:23,600
It works like this. When a server gets these connection requests, the initial connection

417
00:53:23,600 --> 00:53:30,640
requests to send C from the client, what it does, it creates an entry in this table. Right?

418
00:53:30,640 --> 00:53:35,360
Kind of like this, I have a half open means the connection is in progress. It's not, it's not

419
00:53:35,360 --> 00:53:42,320
established yet. So that C results in a new entry in the table. I don't show the entire table,

420
00:53:42,320 --> 00:53:48,080
I'm just showing that. This says, oh, I have a connection that is in the process of being open

421
00:53:48,080 --> 00:53:55,920
with all of these four hosts, right? It's not established yet. And so this table has limitations,

422
00:53:55,920 --> 00:54:01,040
right? It's like maximum size of some sort, right? About 10,000, a million, right? Depends on

423
00:54:01,040 --> 00:54:10,480
a lot. It's a web server, it could be many millions. But when it reaches its limit, right? What you do is

424
00:54:11,040 --> 00:54:20,560
you just delete random entries. Just pick the brand number and delete one. Okay? Next time it's full,

425
00:54:20,560 --> 00:54:25,920
delete one. Now when connections close, right? The entries get flushed anyway, right? Connections get,

426
00:54:25,920 --> 00:54:31,760
in TCP, I don't remember if I said that. There's an explicit connection teardown, right? Using RSD reset

427
00:54:31,760 --> 00:54:38,960
plan that terminates the connection. There's like a handshake there too. Or connection can be terminated

428
00:54:38,960 --> 00:54:44,640
due to timeouts. And whenever connection terminates, of course, the server will remove the entry, right?

429
00:54:44,640 --> 00:54:50,560
Free the entry. So some entries will be terminated one way or another and some will be just randomly

430
00:54:50,560 --> 00:54:54,800
deleted. Now what does that do? That's bad for an honest connection. That is like

431
00:54:55,440 --> 00:54:58,000
an honest host that is trying to establish a connection.

432
00:55:00,240 --> 00:55:05,680
But it's also bad for the fake connections, right? Because if you put it random, right,

433
00:55:06,720 --> 00:55:11,920
the entry to delete, you're penalizing everybody equal. So legitimate connections have a chance to

434
00:55:11,920 --> 00:55:18,320
complete and fake will be eventually deleted, right? Because they will timeout. Now the other thing I

435
00:55:18,320 --> 00:55:25,200
should have mentioned earlier is, of course, the server when it dedicates space, right, or creates a

436
00:55:25,200 --> 00:55:30,400
state that is for a connection that is not established, right, during the three-way handshake,

437
00:55:31,440 --> 00:55:38,160
if the three-way handshake does not complete, that connection will timeout. It will be deleted.

438
00:55:38,160 --> 00:55:44,800
Okay, so it's not like it spawns a thread, dedicates space, and it stays there forever. No, it gets flushed out,

439
00:55:44,800 --> 00:55:52,640
but not soon enough. That's why that original attack worked, because the industry generated

440
00:55:52,640 --> 00:55:56,880
many, many, many, many connection requests at the same time, or almost the same time.

441
00:56:01,840 --> 00:56:08,880
Right. Spoofing. So the other thing is, remember I said sequence number, port numbers, right? Sequence

442
00:56:08,880 --> 00:56:14,480
are like offset, right? When I say sequence number and offset, they're the same thing. And port number,

443
00:56:14,480 --> 00:56:23,360
right? Every connection is associated with the port number. So there is nothing inherently secret in a TCP

444
00:56:23,360 --> 00:56:33,760
connection state. Port numbers, especially for server ports, are easy to guess, right? You don't need to guess them, right?

445
00:56:33,760 --> 00:56:41,360
Okay. They're well, they are signed, right? HTTP, FTP, ICMP, whatever. They're telling that they all have

446
00:56:43,360 --> 00:56:52,400
well-known port numbers. Sequence numbers are not like fixed, right? They change. Sequence numbers means

447
00:56:52,400 --> 00:56:59,440
you start with zero, then you send 1500 bytes, then it becomes 1500, right? You send another 500 bytes,

448
00:56:59,440 --> 00:57:03,920
then it becomes 2000, right? So these are the sequence numbers. Number of bytes exchanged so far,

449
00:57:03,920 --> 00:57:12,720
in one direction. Well, an adversary who is sitting along the path between a sender and a receiver,

450
00:57:12,720 --> 00:57:19,280
right? As the adversary is here, between, might actually see the sequence numbers.

451
00:57:21,200 --> 00:57:24,080
So that adversary can generate like a reset,

452
00:57:24,080 --> 00:57:29,920
and then close the connection, or inject packets into the connection, you see?

453
00:57:32,320 --> 00:57:37,600
Pretending that, you know, that they're part of this connection. But the more interesting thing,

454
00:57:37,600 --> 00:57:41,360
but that's, you could say, well, you know, you could protect against that, maybe this is

455
00:57:41,360 --> 00:57:48,160
inside an organization or behind some kind of a firewall or whatever. But it doesn't have to be inside a

456
00:57:48,160 --> 00:57:53,840
firewall organization. It's just that the adversary might be like here, far away, not on the path,

457
00:57:53,840 --> 00:58:00,080
between the source and destination, right? Most cases, in the realistic cases, in the internet,

458
00:58:00,080 --> 00:58:06,400
right? The adversary isn't actively snooping up, or is actively interfering. He's not on the path

459
00:58:06,400 --> 00:58:11,440
between source and destination. The adversary is somewhere else in the basement of his grandma's home

460
00:58:11,440 --> 00:58:19,360
in Slavonia, okay? So how is that adversary attack? Well, that's the interesting part. The adversary

461
00:58:19,360 --> 00:58:24,320
can actually guess, he knows the initial sequence number is always zero, right? I mean, it's a

462
00:58:24,320 --> 00:58:31,760
typical connection, because it starts with zero bytes. And then he can guess, okay? You just guess.

463
00:58:32,960 --> 00:58:37,680
Well, you say, you know, guessing is hard, because remember I said the sequence number is 32 bits,

464
00:58:37,680 --> 00:58:49,280
right? So guessing 232, not that easy. But remember window size? So if the DCP window size is zero,

465
00:58:49,280 --> 00:58:56,080
which means DCP is super strict, it wants to receive things exactly in order, this attack will not work.

466
00:58:56,080 --> 00:59:03,040
But in the real world, over the internet, right? We communicate DCP session over the internet. There's loss,

467
00:59:03,040 --> 00:59:10,720
packet loss, there's congestion, there's all the other factors that dictate for DCP to have a

468
00:59:10,720 --> 00:59:17,680
flexible window size, the window size of the packets, or offsets it willing to receive, on the

469
00:59:17,680 --> 00:59:24,640
recipient right there. Which means the adversary has a larger space to play with. As long as the

470
00:59:24,640 --> 00:59:30,240
adversary generates packets with the offset within the window size, they will be accepted.

471
00:59:30,240 --> 00:59:42,000
It makes sense. So, that's what we have. And this is especially the case when you are like

472
00:59:42,000 --> 00:59:49,280
communicating with, I say, with your portable devices, with like smartphones. And I see you're driving,

473
00:59:49,280 --> 00:59:53,920
walking around, you're somewhere where the connectivity is not very good, and you have a DCP

474
00:59:53,920 --> 00:59:57,680
connection. And you're watching streaming video, you could be browsing the web, whatever.

475
00:59:58,880 --> 01:00:04,480
But, what happens in these environments, is that there can be sudden, like massive packet loss.

476
01:00:05,600 --> 01:00:10,720
You know, you have a poor connection. It happens. Like, I drive for Crystal Cove,

477
01:00:11,840 --> 01:00:16,800
a bunch of times, every week. You drive on PCH for Crystal Cove, you're going to have that happen.

478
01:00:17,520 --> 01:00:22,080
Because the cellular connection is terrible. And of course, IP runs over cells. So,

479
01:00:22,080 --> 01:00:26,880
there's always a massive packet loss. So, clearly, the window size, on the receiving end,

480
01:00:26,880 --> 01:00:29,920
not to lose the connection, has to accommodate that. And the window size has to be large.

481
01:00:31,440 --> 01:00:34,800
Right? So, what the adversary can do, is instead of sending one packet,

482
01:00:35,520 --> 01:00:40,560
fake packet, injecting into DCP connection, the adversary can just generate the flood of packets,

483
01:00:40,560 --> 01:00:45,920
all with different offsets, right? Or sequence numbers. Hoping that at least one of them will

484
01:00:45,920 --> 01:00:52,320
fit in the window. And if one of them does, well, great. It will be accepted.

485
01:00:58,240 --> 01:01:03,040
Including reset. So, you can also, like, if reset is, like, terminate the connection. It's a,

486
01:01:03,040 --> 01:01:07,840
there's a flag, like, send flag, add flag. In the DCP header, there's, remember, there's a flag

487
01:01:07,840 --> 01:01:13,680
still. And one of the flags is RST, or reset. And that signals to the receiving party that the

488
01:01:13,680 --> 01:01:18,560
connection is being terminated. What's the nature? Well, I mean, it's kind of denial of service,

489
01:01:18,560 --> 01:01:22,400
right? Your connection is suddenly reset. You may have seen, you may see this sometimes,

490
01:01:23,760 --> 01:01:27,440
what in, in some browsers will display, like, connection reset. Have you seen that message?

491
01:01:28,960 --> 01:01:33,440
Black screen, connection reset. Yeah, that means something, the server terminated the connection,

492
01:01:33,440 --> 01:01:38,160
or time had it occurred. Usually, the explicit connection was terminated for some reason. So,

493
01:01:38,160 --> 01:01:47,360
so that's what happens. Not a huge problem in many cases, unless the TPCP connection is critical.

494
01:01:48,400 --> 01:01:51,520
Like, for example, some routing protocols, remember routing,

495
01:01:53,840 --> 01:02:00,480
maintain long-lived TCP connections between adjacent routers. Especially, let's say this is one domain,

496
01:02:00,480 --> 01:02:05,840
and this is another domain, and here we have two border routers. And they maintain this connection.

497
01:02:06,480 --> 01:02:12,400
Long-lived TCP connection. Not for forwarding packets, but for exchanging routing information.

498
01:02:13,760 --> 01:02:19,520
Okay? Like DGP. We'll talk about it later. And if you reset this connection,

499
01:02:21,680 --> 01:02:26,160
that requires them to reset the connection and restart. And routers don't like to do that,

500
01:02:26,160 --> 01:02:30,320
because that's not their critical path. That's not what they do. In fact, they need to do things

501
01:02:30,320 --> 01:02:37,440
fast. Restarting a new routing, sorry, TCP connection takes time. So, that's real denial of service.

502
01:02:40,640 --> 01:02:48,880
Also, UDP. UDP is not as popular as TCP, but it is used. Okay? It's unreliable. Use stands for

503
01:02:48,880 --> 01:02:56,400
unreliable. Tells you everything. Unreliable datagram protocol, which is a very, very lightweight

504
01:02:56,400 --> 01:03:05,680
transport layout that runs on top of IP. It has port numbers, just like TCP, but

505
01:03:08,160 --> 01:03:14,480
doesn't have a connection established with DGP. It was super popular years ago for these P2P

506
01:03:14,480 --> 01:03:21,600
applications. Anybody remember P2P peer streaming? Yeah. So, it was really popular because

507
01:03:21,600 --> 01:03:29,760
the idea was that it was too hard to run TCP servers, right? On like small devices. So, instead,

508
01:03:29,760 --> 01:03:34,720
if you run UDP, you didn't have to run a server. You could just like have light. There's no

509
01:03:34,720 --> 01:03:40,000
establishment connection, no teardown. You just like wanted to grab an illegally copied movie from

510
01:03:40,000 --> 01:03:45,040
somebody near, you know, on a laptop. It just did it quickly without having to establish a connection.

511
01:03:45,040 --> 01:03:53,200
But UDP provides no closeness, no flow control, no windows, nothing. So, UDP flooding is easy.

512
01:03:54,480 --> 01:03:59,840
They just generate a bunch of UDP packets. Now, some, some operating systems, some hosts do not

513
01:03:59,840 --> 01:04:05,280
accept UDP traffic. Some screen it more. But natively, UDP traffic is not screened.

514
01:04:05,280 --> 01:04:13,760
So, well, what can we do about all of this, all of these data? Well, you know, at the Bob

515
01:04:13,760 --> 01:04:19,280
transport layer, we can use things like a purpose, sure, right? Remember that.

516
01:04:22,240 --> 01:04:28,160
A Bob network layer, we can use this as a cell TLS or as a stage. I think Cap is a stage,

517
01:04:28,160 --> 01:04:37,040
a different alternative. And the network layer. Also, okay, but that's, that's a purpose.

518
01:04:37,040 --> 01:04:40,800
Remember, it provides user authentication, client authentication, server authentication,

519
01:04:41,760 --> 01:04:47,920
but does not protect you against, like, network attacks. So, any kind of connection hijacking,

520
01:04:47,920 --> 01:04:54,320
connection spoofing, you know. SSL TLS will protect you at this, kind of this session layer,

521
01:04:54,320 --> 01:04:59,320
but does not

522
01:04:59,320 --> 01:05:03,320
against denial of service. For example, SYN flooding. You cannot

523
01:05:03,320 --> 01:05:07,320
prevent with SSL TLS. Or UDP flooding.

524
01:05:07,320 --> 01:05:11,320
As a network player, you can use IPsec.

525
01:05:11,320 --> 01:05:15,320
IPsec is great. It will protect you against

526
01:05:15,320 --> 01:05:19,320
connection, hijacking, injection, all of the attacks. Pretty much all the attacks I just

527
01:05:19,320 --> 01:05:23,320
described can be fixed with using IPsec.

528
01:05:23,320 --> 01:05:27,320
But IPsec is a heavy

529
01:05:27,320 --> 01:05:31,320
machinery. It demands what we didn't cover is like

530
01:05:31,320 --> 01:05:35,320
establishment of keys and then the actual connection

531
01:05:35,320 --> 01:05:39,320
in maintenance there. It's not free. You will see a performance degradation

532
01:05:39,320 --> 01:05:43,320
for your network.

533
01:05:43,320 --> 01:05:47,320
So it's

534
01:05:47,320 --> 01:05:51,320
pretty much the best solution there is for preventing these kinds of attacks.

535
01:05:51,320 --> 01:05:55,320
mitigating these types of attacks. But like I said, there's

536
01:05:55,320 --> 01:05:57,320
performance penalty and also the key management

537
01:05:57,320 --> 01:05:59,320
is just very, very complicated.

538
01:05:59,320 --> 01:06:01,320
Okay? So if you work for

539
01:06:01,320 --> 01:06:05,320
organization where they set up IPsec, that's great.

540
01:06:05,320 --> 01:06:07,320
But for yourself, it's not easy.

541
01:06:07,320 --> 01:06:11,320
And below network layer, none of these

542
01:06:11,320 --> 01:06:15,320
attacks can be solved except for the one that

543
01:06:15,320 --> 01:06:17,320
the SMART.

544
01:06:17,320 --> 01:06:21,320
Okay, I think we'll end here because the rest of it has to do with routing

545
01:06:21,320 --> 01:06:27,320
and you'll probably forget if I just start.

546
01:06:27,320 --> 01:06:31,320
All right, see you Thursday.

547
01:06:31,320 --> 01:06:48,320
We'll see you from

