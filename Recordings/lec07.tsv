start	end	text
0	12000	Alice's password black, it's determined. Well, that means the adversary commits to a certain J, right?
12000	21000	Where J is a P, J, right? Obviously, the adversary knows all the passwords already, right? All N of them, he already knows in the clear.
21000	31000	But which one is really Alice's password? The probability of guessing is 1 over N, correct, guessing correctly.
31000	44000	So, there she goes, there he goes, he says, I'm Alice, here's a password P, J, indeed P, J exists, right?
44000	52000	And P, J will be authenticated correctly by the server, right? So, these are all passwords.
52000	62000	One of them is Alice's, and one of them the adversary will enter. Maybe the same as Alice's, but yeah, with probability 1 over N.
62000	69000	Which one is Alice's password? Can you tell me by looking at this, what could be her password?
69000	78000	This is not a trick question. There's no, there's nothing hiding in there. It's just a set of random cram.
78000	89000	So, but we're not done, right? So, the adversary will likely make a mistake, right? By guessing an incorrect password.
89000	101000	But what now? So, in other words, how do you verify that it's real Alice or an intruder, an attacker?
101000	107000	Well, this is where the cute little thing comes in, and I'll show you in a minute. That's one question, right?
107000	120000	So, how does the system, right? The system verify that this J is from the adversary, this password J is from the adversary, but password I is from Alice?
120000	130000	And the second, how do we generate these hiding words? So, they all look like what you saw earlier, kind of like indistinguishable or equally likely to be a password.
130000	150000	And you can see that if you generate random passwords that sound like, that look like no human could remember them, and one of the passwords for Alice is something predictable like my friend Bob, then clearly that is the password.
150000	161000	So, that's a tricky question, right? How do we make the bogus passwords, the decoys look real? And then there's, okay, how do you respond?
161000	173000	So, the idea is very simple. You have the system that has, I mean, I'm just showing this as a, the system that has the password, the fc password file.
173000	184000	And it has basically all this, it has means of verifying all these passwords. But in addition to the system that exists today, okay, this is what we already have today.
184000	194000	But instead, I mean, in addition to that, we also introduced a new component, physically separate component, called the honey checker.
194000	204000	And a honey checker's only task is to remember, for every user, the index. The honey checker knows no passwords.
204000	214000	So, think of it as like a really, like, brain damage component, like really stupid component. It just does one thing.
214000	235000	It gets a user name and an index. And it says, yes or no. Yeah? That's it. That's pretty much 99% of it.
235000	246000	So, when Alice logs in, right, and supplies password i, the system will check the password i as it already does today.
246000	257000	Nothing changes so far. But in addition, once they check fast, right, once the password i has been authenticated as Alice's password,
257000	267000	the index i is sent over to the honey checker. And the honey checker does a quick lookup in its little database and says,
267000	282000	Alice has index 5. Is i 5? Yes. All good. Nothing happens. But if i is anything other than 5, well.
282000	293000	So, Alice applies the password. The password is matched to pi, right?
293000	302000	You're so far with me, right? It's not exactly that easy because actually the honey checker needs to compute,
302000	309000	remember, this assaulted hash? But he doesn't know what the i is, right?
309000	316000	So, remember, over here, over here, the password, I show them as being here, but they're not stored like this, right?
316000	321000	Do you remember how they are stored? They are stored in the hash, salted hash form.
321000	330000	So, when Alice supplies the p, the system needs to look up all the Alice's, all the m-t-gerts-part into Alice's,
330000	341000	on each one, compute the salted hash, right? Because the salts are different. So, she computes the salted hash,
341000	353000	then she says, oh, there is a match to pi. And then it sends i over to the honey checker.
353000	362000	And the honey checker just says, yes, does nothing. Or, if the adversary or somebody supplies,
362000	371000	well, it has to be the adversary, actually, if they combine it, be j. And the j, and at this point, the system does not know.
371000	378000	Notice, this big box here, this system has no idea what the index for Alice is, what the index for Bob is.
378000	385000	It does not know any indices. It just knows it has m entries for every user.
385000	394000	So, all it does, it authenticates the user using the supplied password. If authentication succeeds, it says, oh, this corresponds to j,
394000	411000	j, and it sends j to the honey checker. Bam. Wrong. Aligned. So, now you see the whole thing.
411000	418000	Most of the time, the honey checker does absolutely nothing other than just do a lookup. If a lookup succeeds, all good.
418000	429000	That means that j matches i. But if a j is not i, alarm. What does it actually mean?
429000	439000	Notice, if somebody is trying to guess Alice's password, if the adversary does not have the password file,
439000	447000	but it's trying to guess Alice's password. With high probability, with all-knowing probability,
447000	455000	the password that the adversary guesses will not hash into any of Alice's honey passwords, right?
455000	467000	There's only an N of them. So, that's life as usual. The system will say, wrong password, as it does today, right?
467000	478000	And you'll say, just wrong password. Invalid, invalid username, password combination. Yeah? Okay.
478000	482000	So, that experience doesn't change. Alice mistypes her own password.
482000	490000	Forget to shift, cap, whatever. No problem. Wrong username, password combination. Try again.
490000	506000	Same as you do today. But the only way, the only way, again, with high probability, the only way that somebody will guess, or have in their possession,
506000	519000	Alice's password, which is not hers, right? Which is one of the, not i's, right? Anything but i, is going to be somebody who cracked the password file.
519000	525000	Does that make sense? That's the cause for alarm.
525000	532000	So, you wouldn't want any of these alternate passwords to be a very commonly known password?
532000	544000	Right. Right. You don't want them because then you'll be confused, right? Is it, because it has, it cannot be something that somebody would guess about Alice, like trivially, right?
544000	553000	So, that's the, that goes back to how do you generate these details, right? The other question. How do you generate? We are not there yet.
553000	561000	So far, so good? So, yeah, this is already what I mentioned. If the true password is submitted, the user is authenticated.
561000	570000	If a password that is not in the set of Alice's password is submitted, that's a normal authentication error. Okay?
570000	579000	If, if a non Alice's, if a password is submitted, that is one of Alice's, but is indexed, not i, then an alarm is raised.
579000	586000	Only a breach, right? Can cause this. Now you should be convinced. And as you said, they have to be non-treated.
586000	599000	So, if you choose the honey words, judiciously, they will not be like a, a coincidence, right? That you, that somebody, without breaking the password file,
599000	609000	typed in one of the honey passwords. But interestingly enough, as far as Alice, Bob, Charlie, any user is concerned,
609000	614000	there is no change in their experience, right? They don't need to remember two passwords. They still remember one.
614000	620000	They still enter user name, password, hit return. Nothing changes. That's another nice thing.
620000	629000	You don't want to change the user experience, right? Because user experience requires change, requires training. Adaption. Right?
629000	635000	Different users adapt differently. But if you tell them, oh, it's the same as before, just there is something in the back.
635000	641000	Maybe you don't even tell them. They don't need to know.
641000	655000	So, the nice feature here is that the system that today hosts the password file that authenticates you, just needs to transmit the index.
655000	662000	Like minimal information, right? Just name of the person, of the user, and the index.
662000	673000	And so, very little modification, right? You just introduce kind of a call, right? An additional call after you have authenticated the password, right?
673000	680000	Here. After the password has authenticated, you take the index, and the user name, and send it to the honey checker.
680000	691000	And you wait for reply, right? And if the honey checker says yes, cool, honey checker says no, alarm, lock up everything, yeah.
691000	700000	And this is kind of a very trivial way of implementing distributed security, right?
700000	704000	So, the honey checker, of course, is not a full-blown computer system with accounts, right?
704000	712000	You want the honey checker to be a device or a computer that is at most as one account, I mean, basically, like, administering,
712000	720000	user, right? Or a root account that is touched and logged in almost never, right?
720000	726000	Only when the password file and indices are updated.
726000	737000	In fact, you can keep indices the same even if you change the passwords, because they are only known to the honey checker.
737000	746000	No single point of compromise. So, for example, if the computer system is compromised, well, we said, right,
746000	754000	the password file is a hack, you learn about it, right? Because the first user, the first time the adversary
754000	760000	threshold again for any user, for any Alice, Bob, and Charlie, alarm will be erased, and that's it.
760000	767000	The adversary gets one chance. And so, whatever user he picks, Bob, Charlie, Alice, assuming, let's say,
767000	774000	n is some reasonable number, like 20, his chances of getting in a one out of 20.
774000	781000	He might get like, but he's got only one chance, and it's one out of 20.
781000	786000	How long would you update the password without knowing you being fixed?
786000	795000	Well, that has to be done offline. That's not the pretty part. Because if you want to update, if you, well, let's think about it.
795000	797000	You can do it if they gave you their old password.
797000	803000	Yeah, yeah, yeah. I mean, password change, password change programs are separate. Actually, that's a whole, like, separate lecture.
803000	818000	Doing password changes is an underappreciated problem, and a difficult one. Especially considering what happens if you have disconnects in the process.
818000	827000	Meaning that, at some point, the protocol for changing password breaks, like because of the system malfunction or network disconnect,
827000	833000	and you have essentially a user who thinks the password changed, the system does not, or the other way around.
833000	837000	So, that's a careful thing. That's a problem with all password changes, right?
837000	843000	So, the only way to assure your password changes is to actually manually log in into the system and password change,
843000	849000	instead of remotely, physically close. All right? But, that's not scalable, right? We don't want to do that.
849000	856000	So, that's a whole different headache that is not really different, so much different from the, the case when you use Honey,
856000	869000	Honey passwords. But, let's see. If the Honey checker fails, right? It just, the system still will function, right?
869000	876000	Like, if Honey checker goes down, it uses a hardware failure, or some sort, or it gets disconnected,
876000	883000	the system will function. It will just default to what we have today. It will get no worse than what we have today.
883000	890000	So, if the computer system fails, well, you can't log in, but that's the same experience we have today, right?
890000	898000	So, nothing changes so much, if either component, right, is compromised, you don't, it's not failed.
898000	908000	If you, well, sorry, if it fails, if it fails, it's not failed. Now, if either is compromised, like I said, if the computer system is compromised,
908000	915000	well, that's the case we already assumed, right? That the adversary compromised it, and learned the password.
915000	922000	Now, if somebody compromised the Honey checker, without compromising the system, right? So, okay, this is secure,
922000	930000	the adversary does not know the et cetera password file. It just breaks in here, oh, the adversary learns usernames and indices,
930000	940000	but that's it. That doesn't help the adversary to log in. Now, what happens if the adversary compromises both, which is, of course, should be unlikely.
940000	945000	If the adversary compromises both, it gets no worse than we already have.
945000	950000	If you think it through, the situation is strictly no worse than we have today.
950000	955000	Because when the adversary learned the indices, and the adversary learned the password file,
955000	961000	well, he just still has to brute force all the passwords, right, as he would today, so nothing changes.
961000	974000	And Honey checker can be a very, very, like a simple operation.
974000	984000	This may not be, so, if you have, for example, a wire between them, right, like an ethernet wire or some other fiber optic wire
984000	995000	between the computer system and the Honey checker, basically you don't even need any output from the Honey checker.
995000	1004000	And the reason is that you know that it received, right? When you send something over a wire, you know it will be received.
1004000	1009000	Then you have a dedicated wire between the two devices.
1009000	1014000	So, what if nothing, what if, what if this is a legitimate login?
1014000	1018000	Well, silence, everything okay?
1018000	1023000	What if it's illegitimate, meaning that this is an adversary supplying some BJ?
1023000	1026000	Well, in that case, a physical alarm will go on, right?
1026000	1029000	The doors will lock, the administrator will be alerted, right?
1029000	1034000	So, some physical consequences will happen, right?
1034000	1043000	So, what this is, essentially, it's an input-only system, that you just give it name, index, name, index.
1043000	1047000	And in case of a problem, it will raise a real alarm.
1047000	1053000	In practice, you may still want to know as soon as possible, but still.
1053000	1055000	Make sense?
1055000	1062000	So, it can be, like, downstream somewhere in an operations center.
1062000	1073000	So, clearly, you want the Honey checker to be more secure, because this is obviously accessed by, this system will have multiple user accounts, right?
1073000	1075000	Because they are all logging into it.
1075000	1077000	They will have the system administrator.
1077000	1080000	The Honey checker can be, basically, not untouched, for the most part.
1080000	1092000	So, sitting there, in a box somewhere, does it need a screen, does it need anything, just sit in a box, in a closet, in a, you know, behind an armored door or something, and that's it.
1092000	1093000	Right?
1093000	1095000	It just gives this sort of rapid alert.
1095000	1096000	Right?
1096000	1097000	So, I reset that.
1097000	1098000	Okay.
1098000	1102000	Now, we come back to this issue of Honey word generation.
1102000	1103000	How do you do it?
1103000	1105000	Now, look at this.
1105000	1107000	Which one is the password?
1107000	1116000	Obviously, the next to last, because it's the only one that looks like human language.
1116000	1119000	The rest look pretty random.
1119000	1128000	So, it's very likely, I'm not guaranteed, maybe Alice is a genius, can remember, like one of those savants, can remember a string of two characters, but don't like it.
1128000	1129000	Right?
1129000	1130000	So, boom.
1130000	1131000	Done.
1131000	1132000	This one.
1132000	1136000	So, well, what could we do?
1136000	1148000	Remember, we have Password Crackers, the software, right, that, that, you know, breaks passwords, and it, you know, generates human readable passwords.
1148000	1161000	So, we can kind of take passwords, right, potentially decoy passwords, from prior breaches of, like, of password databases, and repurpose them.
1161000	1170000	By adding a letter, a number here, an exclamation, or a question mark, or a comma, or a period, right?
1170000	1174000	Because they are already human passwords, right?
1174000	1176000	The ones from, like, a raw human database.
1176000	1189000	Just grab some, not too popular, but, like, grab some mildly popular password, and tweak it a little bit, and make it a decoy.
1189000	1190000	Right?
1190000	1195000	So, let's say it's something like this.
1195000	1200000	Well, now, now it's difficult, right?
1200000	1206000	If you're that attacker, you're, you're kind of out of luck, looking at these, these passwords.
1206000	1213000	They could all be Alice's password.
1213000	1218000	Happens to be that, but could have been any other?
1218000	1221000	Okay, there are problem cases.
1221000	1234000	Now, if you look at this, which would be more likely to be the password here?
1234000	1236000	My guess is, not wild guess, right?
1236000	1238000	It's probably the second, right?
1238000	1241000	It just kind of sticks out at you.
1241000	1242000	Right?
1242000	1245000	It's mostly more timely, also.
1245000	1246000	All right.
1246000	1249000	So, not good, right?
1249000	1251000	This is not a good selection.
1251000	1263000	Now, if every one of them said, I don't know, down with Joe Biden, down with Donald Trump, down with Gavin Newsom, down with, I don't know, Maduro, et cetera.
1263000	1264000	Yes.
1264000	1265000	Okay.
1265000	1268000	That would be hot.
1268000	1270000	Because they all look very similar.
1270000	1273000	But, but this, hmm.
1273000	1284000	So, one way to generate similar believable passwords is by what's called tweaking.
1284000	1285000	Oh, yeah.
1285000	1293000	So, essentially, you know, I'll put you to the paper, but of course nobody's going to look at it, but the idea is very similar.
1293000	1295000	Tweak the actual password.
1295000	1308000	Take, take the user's actual password that he or she picked and tweak them a little bit to generate, like, minor variations.
1308000	1318000	That has problems, but, something like this.
1318000	1325000	So, both lines are passwords, like gamma half, pacificer six, and this is contamination, right?
1325000	1328000	So, all four of these are passwords.
1328000	1336000	I mean, nobody, I'm saying, well, he thinks that your password is very long, but, but you get the idea, right?
1336000	1338000	They all have similar structure.
1338000	1344000	They all start with, like, the same sort of human readable part, and then there are these numbers, right?
1344000	1350000	Three, two, one, four, five, six, seven, and then there are the sequential numbers, but they all look very similar.
1350000	1354000	Now, looking at this, it's very hard to say, right?
1354000	1362000	So, one of them is, is obviously the password, and the rest are tweaked, but which are tweaked?
1362000	1363000	Why?
1363000	1369000	Because all the other ones, it has the one that has the most common numbers and letters.
1369000	1376000	Maybe, maybe, maybe, but it happens to be this one.
1376000	1381000	No, I mean that, of course, it's a synthetic example, but it happens to be this one.
1381000	1388000	But you get the idea, chaffing is a, does everybody know what the word chaff means?
1388000	1397000	Chaffing, like, when you have weak chaff, you know, stuff that is like fluff, noise.
1397000	1402000	So, the rest of them are noise, right?
1402000	1406000	So, here's another problem.
1406000	1413000	Here you have a bunch of very similar passwords, right?
1413000	1418000	Which one is the real password?
1418000	1420000	Any guesses?
1420000	1425000	I know you, you have a guess, but does anybody want to guess?
1425000	1426000	Okay.
1426000	1427000	It's the fourth one.
1427000	1428000	It's the fourth one.
1428000	1429000	Why?
1429000	1430000	The band.
1430000	1431000	The band.
1431000	1435000	Now, of course, now you know this, except for him, I don't know why he knows, but it's
1435000	1440000	a band from, you know, some, a couple of generations before you.
1440000	1441000	It's a rock band, right?
1441000	1446000	So, it has meaning.
1446000	1449000	The rest of them are kind of random, right?
1449000	1451000	But this one has a real meaning.
1451000	1457000	Looks random, but it is not.
1457000	1465000	So, the semantics of these particular passwords are significant, whereas the rest of them don't
1465000	1467000	have any real semantics.
1467000	1472000	So, if you just tweak by generation, like if the real password is Blink 182, and you start
1472000	1478000	generating Blink 123, Blink 183, well, none of them are rock band.
1478000	1482000	So, somebody who knows this will look at it and say, uh-huh, I know exactly what the password
1482000	1483000	is.
1483000	1485000	That's difficult.
1485000	1490000	I think today you can get GBT to generate some meaningful passwords.
1490000	1495000	Maybe, now this stuff wasn't proposed in an LLM era, right?
1495000	1496000	It was before.
1496000	1497000	Yeah.
1497000	1498000	You probably can.
1498000	1499000	But there's a better idea.
1499000	1505000	You can just repurpose other people's passwords.
1505000	1511000	You know, even conceivably on the same system takes Bob's and Charlie's passwords and throw
1511000	1514000	them in his chaff and Alice's mix.
1514000	1518000	They're as believable as Alice's passwords, you see?
1518000	1521000	You can do that.
1521000	1524000	Well, basically, what is this?
1524000	1525000	What is the idea?
1525000	1527000	What is the honey password scheme?
1527000	1534000	It's an example of distributed security, kind of inexpensive distributed security that
1534000	1538000	strictly strengthens the resilience of the system.
1538000	1540000	Now, it's not going to prevent password breaches.
1540000	1543000	It has absolutely nothing to do with prevention.
1543000	1548000	It has everything to do with timely detection.
1548000	1549000	Okay?
1549000	1557000	So, it will, it's purpose only one, to detect ASAP when something happens, like a password
1557000	1560000	file is compromised and the adversary tries to gain access.
1560000	1561000	Yeah?
1561000	1566000	Can the adversary use these correct passwords and maybe attempt them on a different website?
1566000	1567000	Of course!
1567000	1569000	And they're forgetting that they're using the password.
1569000	1570000	Of course.
1570000	1571000	Of course.
1571000	1572000	This is not a panacea.
1572000	1574000	This is not magic, right?
1574000	1577000	The adversary stole the password file.
1577000	1580000	And Greg told his password.
1580000	1585000	He can try them on a different system because many of us, we use passwords.
1585000	1588000	We do, unfortunately.
1588000	1596000	Now, some, some password guideline checkers, you know how when you select your password,
1596000	1602000	you are asked to enter, I mean, must have at least one lowercase, one uppercase, one special character,
1602000	1603000	and one number, right?
1603000	1605000	I think usually that's what you see I say.
1605000	1606000	And the length, right?
1606000	1609000	Eight characters at least, I think, for us.
1609000	1613000	What was the last time anybody changed the password?
1613000	1616000	I think I have.
1616000	1617000	Okay.
1617000	1619000	You haven't changed the password either.
1619000	1620000	I have.
1620000	1621000	I have.
1621000	1622000	But I just don't remember the number.
1622000	1627000	There are these other rules, but I remember, I think it, I think it's eight.
1627000	1635000	Anyway, so some of the systems will have an additional guideline where you must insert
1635000	1640000	the name of the system you are logging in into your password.
1640000	1643000	Meaning that this is like uci.edu.
1643000	1647000	So your password should have uci.edu in it.
1647000	1648000	That is a pain.
1648000	1653000	Not because if you have uci.edu, that part isn't useful.
1653000	1658000	So you have to essentially add this to your password at the end or in the beginning.
1658000	1660000	You're not going to sprinkle it throughout.
1660000	1666000	And if the limit is eight, well you should not count these seven characters as part of
1666000	1667000	the password.
1667000	1669000	And for strength purposes, right?
1669000	1674000	So essentially, by mandating that you all use uci.edu in your password, I'm saying that
1674000	1680000	your password has to be at least 15 characters long, right?
1680000	1683000	You see what I'm saying?
1683000	1686000	Now, but that would solve a problem, right?
1686000	1692000	In that you could not then reuse, well, it would be awkward for you to reuse that same
1692000	1701000	password because it contains uci.edu on, I don't know, wellsfarga.com.
1701000	1706000	But that's a balance between password usability and password strength.
1706000	1708000	Now, back to your question.
1708000	1709000	There's one other problem.
1709000	1712000	Yes, the adversary could try.
1712000	1717000	But remember, the adversary still doesn't know the right index.
1717000	1722000	So it's very likely it's going to be frustrating for the adversary if the other system also
1722000	1724000	implements a honey checker.
1724000	1726000	Well, they would have different honey.
1726000	1727000	That's right.
1727000	1730000	But then they usually have different passwords.
1730000	1735000	Right, but they just have to try like 20 times and then one of them works.
1735000	1736000	No, no, no.
1736000	1742000	Yes, if the other system, so let's say you broke into, you got uci.edu password for you.
1742000	1747000	And then you went to Wells Fargo and they tried to log in as u using those passwords.
1747000	1752000	But if Wells Fargo also implements a honey checker, that ain't going to work, right?
1752000	1755000	I mean, it ain't going to work.
1755000	1757000	Actually, no, let me take it back.
1757000	1764000	It will work because one of them is probably, yeah, not probably, one of them is going to overlap.
1764000	1767000	So actually, yeah, it might actually work.
1767000	1768000	You need to compare it.
1768000	1769000	That's right.
1769000	1771000	Well, no, no, you don't have to break in to compare.
1771000	1773000	If you break into Wells Fargo, then you can compare.
1773000	1774000	But that's a high bar.
1774000	1776000	I think actually you're right.
1776000	1779000	You could take them to another website and try 20 times.
1779000	1782000	Now, after three or four times, you'll get locked out.
1782000	1785000	So you would have to do this under radar.
1785000	1795000	Remember I mentioned that a good hacker or adversary does not rush to victory.
1795000	1804000	If I know 10 passwords for you and only one is real, I'm not going to try one after another.
1804000	1808000	I'm going to try one and cross it off by myself.
1808000	1810000	And I'm going to get an education payment.
1810000	1820000	Then knowing that you log into Wells Fargo once a day, suppose, I will wait a day.
1820000	1824000	And during that time, you would have logged in successfully.
1824000	1825000	Okay?
1825000	1826000	Reset the counter.
1826000	1829000	I will try the second answer.
1829000	1830000	Doesn't work?
1830000	1831000	Cross that off.
1831000	1832000	Wait another day.
1832000	1834000	You get what I'm going?
1834000	1836000	Smart adversary will do that.
1836000	1847000	Notice that most systems do not warn you when you log in successfully whether they have been in successful attempts before.
1847000	1851000	Whether they should or not is an interesting question in and of itself.
1851000	1857000	Because if they start telling you it will be meaningful only if you have good memory, if you log in regularly, you know what I mean?
1857000	1864000	Like if you are one of those ill retentive people that logs it every day at 8 a.m. to your Wells Fargo account, yes, you will know.
1864000	1866000	You say, what the hell?
1866000	1869000	At 4 p.m. last night somebody entered the wrong password.
1869000	1870000	Ah!
1870000	1875000	But if you are like most people, you don't remember, you don't have that capacity.
1875000	1878000	Most of us don't do this already.
1878000	1879000	Everybody following this conversation?
1879000	1880000	Yeah?
1880000	1881000	Okay.
1881000	1885000	So, anyway, back to this world.
1885000	1889000	This is a nice balance between deployment and security, right?
1889000	1892000	Because it's relatively easy to deploy.
1892000	1896000	Minimally simple, blah, blah, blah.
1896000	1900000	Now, two follow-up questions and we are done.
1900000	1901000	That was two interesting things.
1901000	1903000	Actually, what you raised is also interesting.
1903000	1905000	I hadn't thought about that.
1905000	1911000	Can we repurpose this theme to add a separate password?
1911000	1915000	The Alice would have to remember two, two passwords.
1915000	1922000	Well, one of them is real password and the other one is I'm being threatened, I'm under duress.
1922000	1932000	Notice that banks use this system, you know, for PIN codes and combinations for like saves and stuff.
1932000	1934000	There's two combinations.
1934000	1936000	One is emergency, one is real.
1936000	1940000	When you enter an emergency combination, the safe will open.
1940000	1944000	But they will immediately notify the police or security.
1944000	1946000	So the idea is the same here.
1946000	1951000	If you have a list of, if you are Alice and you have a list of N passwords,
1951000	1957000	it would be nice if you remembered two and only entered that other second one in case of emergency.
1957000	1961000	Somebody puts a gun to your head and says, you know, log into your bank account and transfer money.
1961000	1966000	Well, you enter, but the bank now knows that somebody is threatening you.
1966000	1968000	Yeah, it'd be cool.
1968000	1972000	And it can be done with the honey checker, right?
1972000	1979000	The honey checker would raise an alarm when you enter that password that is signified in the emergency.
1979000	1982000	And now, finally, there is a problem with the honey checker.
1982000	1986000	Nothing is just beneficial.
1986000	1991000	One of the things that the industry may aim to just recap it.
1991000	1993000	Maybe the industry doesn't care to get into the computer system.
1993000	1996000	He wants to inconvenience you as much as possible.
1996000	2003000	So you imagine you are a large-ish organization where the system has numerous accounts, maybe thousands, right?
2003000	2009000	This et cetera password file has like thousands or hundreds of accounts, employees, right?
2009000	2014000	The adversary breaks one password.
2014000	2016000	Just one.
2016000	2017000	Okay?
2017000	2020000	He wants to take his chances.
2020000	2022000	He doesn't have to crack all of them, right?
2022000	2023000	So the answer is easy.
2023000	2024000	And enters that.
2024000	2025000	Says, Alice, here's password.
2025000	2026000	User name Alice, here's password.
2026000	2028000	Immediately the alarm goes on.
2028000	2031000	What happens at that point?
2031000	2036000	At that point, everyone is locked out and everybody must change their password.
2036000	2039000	That's a giant nightmare.
2039000	2044000	So the adversary could be very happy just achieving that.
2044000	2049000	If the adversary's goal is denial of service.
2049000	2051000	Questions?
2051000	2056000	No questions.
2056000	2057000	All right.
2057000	2058000	All right.
2058000	2061000	Now it's time to switch to something different.
2061000	2066000	Let me share the screen.
2066000	2067000	All right.
2067000	2077000	Now we're going to switch over to something called single synon or something called Kerberus.
2077000	2079000	Anybody ever heard of Kerberus?
2079000	2082000	Not from Greek mythology, but actual Kerberus.
2082000	2083000	Yeah.
2083000	2084000	Okay.
2084000	2086000	Everybody ever heard of single synon?
2086000	2087000	Okay.
2087000	2093000	Well, some of you, many of you probably already used Kerberus without knowing it.
2093000	2096000	Windows authentication, right?
2096000	2097000	Distributed authentication on Windows.
2097000	2103000	If you ever use ICS facilities for using, you know, Windows network, you've used Kerberus.
2103000	2105000	It's underneath.
2105000	2108000	And then we'll go on to web security.
2108000	2109000	All right.
2109000	2112000	So what is Kerberus or what is single synon?
2112000	2114000	The idea of a single synon is very common.
2114000	2117000	You have used it on the web, although not using Kerberus.
2117000	2121000	Anybody know what OAuth is?
2121000	2122000	Two people.
2122000	2123000	Anybody else?
2123000	2124000	Three.
2124000	2125000	Okay.
2125000	2127000	Anybody want to tell me what OAuth is?
2127000	2130000	Based on, no wrong answers.
2130000	2132000	What is OAuth?
2132000	2133000	No?
2133000	2134000	What does it do for you?
2134000	2135000	Okay.
2135000	2136000	Let me ask you.
2136000	2137000	What does it do for you?
2137000	2138000	You can access a different application.
2138000	2139000	It's like an authentication.
2139000	2140000	Right.
2140000	2141000	So you log into Facebook.
2141000	2144000	And you want to access, I don't know, TikTok or Instagram or something like that.
2144000	2145000	Snapchat.
2145000	2146000	And you do it without having to provide your username.
2146000	2147000	How is that possible?
2147000	2148000	Facebook instead?
2148000	2150000	Well, it's not because everybody loves Facebook and respects Facebook.
2150000	2151000	No.
2151000	2152000	It's just Facebook authenticated you as somebody.
2152000	2161000	And Facebook basically passes your credentials over to Instagram and says, this user has been
2161000	2162000	authenticated.
2162000	2163000	Google does the same thing, right?
2163000	2164000	With Gmail.
2164000	2165000	You're authenticated with using via Gmail and then you can use Google Drive.
2165000	2166000	They had different applications.
2166000	2167000	But you only signed on once.
2167000	2169000	So the whole idea is to make it easy for users like you and you.
2169000	2172000	You can make it easy for users like Google Drive to get your credentials.
2172000	2173000	It's not because everybody loves Facebook and respects Facebook.
2173000	2174000	No.
2174000	2175000	It's just Facebook authenticated you as somebody and Facebook basically passes your credentials
2175000	2177000	over to Instagram and says, this user has been authenticated.
2177000	2178000	Google does the same thing, right?
2178000	2179000	With Gmail.
2179000	2180000	You authenticated with using via Gmail and then you can use Google Drive.
2180000	2182000	They have different applications but you only signed on once.
2182000	2193000	So the whole idea is to make it easy for users like you and Google Drive to use Chrome.
2193000	2200760	users like you and me, first to remember fewer passwords, and second having to authenticate
2200760	2207080	many many times. You know what it means to authenticate many times. Not just because
2207080	2211080	let's say IMT requires us to re-authenticate, but I'm talking about authenticate many times
2211080	2220040	to different applications. So that's the whole idea behind single sign-on, is that you sign
2220040	2228040	on, you log in. Sign on is just another word for login. You log in once, and you don't do it for every application.
2229400	2235720	So the basic problem that Kerberos in general, single sign-on tries to solve is this. You have
2236360	2245640	many users and you have many what's called servers. If it helps you think of servers as being even like
2245640	2255640	apps or applications that run on different places. Originally and even today, the Kerberos is mostly
2255640	2263240	used within organizations. So suppose you're working in an organization like UCI or a commercials entity
2263240	2271480	of some sort of company. Not a tiny starter, but a company of certain size. And so you have a bunch of
2271480	2279080	users with different job titles and different privileges. Some users can access some resources,
2279080	2285880	some and not others, and no different users depending on their job, may have unique access
2285880	2291560	policies governing their access to resources. There are compute servers, there are GPUs, there are storage
2291560	2298440	devices, there are printers, there are 3D printers. There are all kinds of equipment and there are all kinds of
2298440	2305160	services that those that equipment gives you, right? So we call those things servers in this lecture.
2306680	2314440	So the main problem is how a user proves their identity, right? Through a multitude of servers,
2314440	2321160	right? Because a given user will come in the morning to work, will log in, and then during the day,
2321160	2326360	in the course of a typical day, will want to access some service. I want to print a document,
2326360	2336760	access company calendar, I don't know, run a job on an expensive GPU rack somewhere, okay? These kind of services.
2338360	2346920	So, clearly a naive solution is to say, well, every service or every server that offers a service
2346920	2351960	should have its own account database, should have its own account database, and every user that is
2351960	2360760	allowed to access that server should have an account, okay? That could make sense. So if you want to,
2360760	2367160	if you're allowed to use the GPU farm, well, have an account there. If you're allowed to use that printer,
2367160	2373160	well, there's going to be a printer server that will maintain that account database. Same for storage devices and anything else.
2373160	2387000	That would work, but it wouldn't scale. Because that means that we have, coming back to the problem
2387000	2392040	with the password issue we discussed in the last couple of lectures, you would have to, as a user,
2392040	2401160	as an employee, you would have to remember as many passwords, as many user names, but at least as many
2401160	2407240	passwords, maybe the username is the same, as many passwords as there are servers, and you will
2407240	2414920	physically have as many accounts as there are servers. And of course, if you have all these servers,
2414920	2422040	each running its own account database or accounting system, well, an adversary who breaks into any of
2422040	2427160	them already gets something. Potentially, if you reuse passwords, you will get your passwords on other
2427160	2433720	servers. And we know the people who use passwords, right? So it's not a scalable world if you have
2434520	2440520	every server maintaining its own database of users and doing its own access control.
2444440	2445000	All right, so
2447720	2455880	even if you do, in fact, have the same password for every server, right, separately, if you want to change it,
2455880	2460600	you would have to contact each one individually, which is tremendous damage.
2463400	2469000	So, clearly, we want to do something better. We want to have better security,
2469000	2474920	means be secure against eavesdroppers and actively malicious adversaries. Remember,
2474920	2480760	eavesdroppers just listen, malicious adversaries, actively active adversaries interfere, right?
2480760	2486120	They introduce their own traffic, they delete traffic, they retard traffic, they change traffic,
2486120	2493000	right? When I say traffic, I mean packets, communication. Also, adversaries can keep that in
2493000	2498120	mind, and always in this course. Adversaries could very well be legitimate users who are inside.
2499480	2507320	A lot of spectacular breaches in this world occur, not because of the evil hackers in a third world
2507320	2514760	country or some other faraway place, they occur because there's a rotten insider in their organization.
2515880	2521480	Of course, there must be reliability, so that whatever service you do, it must be always available.
2521480	2528280	Users should not have to enter passwords and authenticate multiple times. The whole point is
2528280	2533000	log in once and get access to as many servers and services as you can.
2533000	2541880	So, if a user is asked to enter a password, doing so like once a day is considered okay. Maybe twice a day,
2541880	2547560	but not every time you want to do something. That's super annoying. We all know this, right?
2549080	2556280	It's annoying what we have here at UCI. And of course, it must be scalable, right? Because we want it
2556280	2561000	to scale to large number of users and maybe smaller, but still a large number of servers.
2564120	2570920	We want to deal with impersonation or when Alice is a legitimate user and Bob decides to log in as Alice,
2570920	2577160	or some outside adversary just tries to log in. We cannot trust the location. For example,
2577160	2581160	if you work in a company where computing, and many companies do this, right? They don't allow you to
2581160	2590280	bring personal devices like laptops, right? You come to work, you either take your work-issued laptop
2590280	2596360	and plug it in to the docking station, or you don't do even that. You just come to work and you log into
2596360	2604520	the workstation on your desktop, whatever that is assigned to you. So, trivial idea would be to just say,
2604520	2610600	well, you know, a person gained access to this desktop and this desktop is inside the secure premises,
2610600	2616680	therefore, it's enough to just use an IP-based authentication, IP address-based authentication.
2616680	2622200	That's not good. That's not good enough because IP addresses and even MAC addresses can be changed.
2623080	2624920	Okay, so they're a poor form of authentication.
2624920	2637000	Let's see. You have to be resilient to eavesdropping. You have to be resilient to replay, right?
2637000	2643480	Replay is just basically replaying previously sent information, right? If you trap somebody's password
2643480	2648680	in a clear text or somebody's packet that is actually, forget clear. If you trap a packet that has
2648680	2654840	Alice's password in an encrypted form and you know that that packet carries Alice's password
2654840	2660920	in an encrypted form, you can replay it at a later time and gain access to Alice's account,
2661640	2667480	unless the password carries it in some other information like, for example, timestamp or something
2667480	2677160	else. Okay, so you get the idea, I think, of what we want to do. So in Kerberos, the main component is
2677160	2684520	something called the trusted third party. Trusted third party, or TTP, is the general concept.
2685160	2690040	Okay, and by the way, Kerberos is called Kerberos because it's a three-headed dog from Greek mythology.
2690760	2696440	There's some story behind it that I don't quite remember. Anyway, the idea is this. That
2697320	2706840	pink box with the three dogs, that's the Kerberos trusted third party. Think of it as like the system.
2707720	2718200	It is trusted. It maintains a relationship with every user and with every server. Okay,
2718200	2725880	it's like the security brains of their, of the organization. So it knows all passwords. Oh,
2725880	2734840	knows, I mean, knows as much as like a UX, that's the password. Actually, no, it knows all
2734840	2740520	passwords for all users and it also performs what's called access control. So when a user comes in and
2740520	2747480	comes in and authenticates and later the user says, oh, my name is Alice. I have authenticated.
2747480	2754600	I want to access the GPU farm to run this job. The server, this trusted third party will say,
2755400	2761800	are you allowed to do so? And that's called access control, right? This is separate from everything
2761800	2766680	we discussed so far, right? Access control means do you have the right to access the GPU farm?
2767720	2774360	Maybe Alice is not because Alice worked in the janitorial department. But Bob, who works in a,
2774360	2785640	I don't know, coding department is allowed to ask. But maybe Alice is allowed to, you know, access some
2785640	2792600	financial system and Bob is not. Okay? So you get the idea. Access control is very important and they,
2792600	2797000	one of the roles of the trusted third party is to perform access control.
2797000	2806280	It is a convenient entity because there's only one. You authenticate only to it directly as a user.
2807560	2813080	And you do not authenticate directly to anybody else but the trusted third party.
2815960	2820360	It is also, I admit from the start, anytime you have a system like this,
2820360	2826760	it's going to be a single point of failure. So that is true about all systems that use trusted third party.
2827000	2834360	Unless there's a hot backup somewhere. Okay? If the system fails, nobody can log in. Nobody can access it.
2836360	2841560	Okay? That's from, that's, that's a problem. That's part and parcel of the curbers.
2842200	2847560	And clearly that requires physical security, kind of like I mentioned earlier with the certification
2847560	2853240	authorities, right? Require special security accommodations while so does the curbers trusted third party.
2853240	2866680	So here's a, a bird's eye view. A user, let's say, comes in the morning and enters username, password.
2866680	2875880	So that's the user experience. What's it? Well, assume, right? So basically proves identity and says,
2875880	2881720	okay, now I want to access some server, like a print server. Okay.
2881720	2890520	Okay. User then, if he's authorized, only if authorized, will receive a, what's called a ticket.
2891640	2896840	And a ticket, like a ticket in the middleware, allows him to go to the print server and say,
2896840	2910200	see, see, I got a ticket, I can print on you. Right? So that's essentially a high level,
2910200	2916920	the interaction in curbers. And that's pretty much how most single sign-on services work in the real world.
2916920	2923480	So you authenticate as a user once, and from that point on, everything else takes place under the curbers,
2923480	2925400	being transparent to you, the human.
2929080	2936840	So what is that mysterious ticket? Well, a ticket should be, as you can already guess,
2936840	2943800	something secure, something cryptographically protected. Right? Because if it's not cryptographically
2943800	2949320	protected, it can be hijacked, it can be modified, reused, abused, et cetera. So there's going to be
2949320	2955080	some cryptographic protection for sure. It cannot include a server's password, obviously. Remember,
2955080	2961800	the server, I did forget to mention this. So in curbers, every user shares a password,
2961800	2968920	or a long-term key with a trusted third party. But also each server shares a long-term key with a trusted
2968920	2975960	third party. Okay? So as far as the trusted third party is concerned, it has a database of all the
2975960	2982440	users and all the servers. And for each user and for each server, it has a long-term key. Okay?
2982440	2988120	Except for servers are not humans, so that key does not need to be a password. It can be a random,
2988120	3002040	strong, long key. And it shouldn't change very often. So the ticket must have some information
3003800	3010920	that only the server can read and understand that tells the server that this user is authorized to use
3010920	3019800	this service right now. And for how long? So remember, it's important to tell the server, like the print
3019800	3027720	server, that this ticket is for you. This is for the print server. And it refers to the already
3027720	3035880	authenticated user, Alice. So this is for Alice to print on you now. Because if you don't say when,
3036840	3042600	then the ticket can be used by others, right? Or it can be used by Alice in perpetuity.
3045160	3051640	But remember, in the real world, Alice may be a good employee today and a fired employee tomorrow.
3052920	3058600	Yes? So that's why tickets are only issued for a certain period of time.
3058600	3067880	8 hours, 10 hours, 24 hours. Kind of like our authenticators here would do, right? When you
3067880	3073160	use, when you log into UCI services, right? Eventually, your ticket will expire. And you'll get
3073160	3083080	a new window to re-authenticate. The same idea. Okay, so the ticket is something, in this case,
3083080	3089000	encrypted for the server with a key known only to the server and the DTP. But the user has no idea
3089000	3093640	about that key. Server can then decrypt the ticket and verify the information and says,
3093640	3099000	oh yeah, this is for me, because I can decrypt it, so it must be for me. And it refers to Alice. Well,
3099000	3106040	Alice is that user. And of course, lack of print. And do whatever.
3106040	3112520	All right. All right. So that's essentially how it goes.
3119480	3126680	Inside the ticket, you would want to find the username, meaning this is the server to whom it's
3126680	3133720	issued. The name of the server is who am I, the server, brain server, right? Who is the user?
3133720	3139720	Alice. Address of the user workstation. That's important so that the ticket is not movable from
3139720	3145160	one place to another. The ticket is valid for this device. You know how, with a single sign-on,
3145960	3151560	with an OID, if you change devices, you'll have to re-authenticate. You move from one laptop to
3151560	3156280	another, or desktop to laptop, or smartphone, whatever, you re-authenticate. Same here. There's
3156280	3163880	an IP address. Even though IP or address is not a reliable form of authentication, the ticket is
3163880	3174600	tied to the IP address. Yeah? Important. Lifetime. Valid from, valid to, or until. Why is that? Because
3174600	3179240	we want to know when the ticket is valid. Sometimes it's not valid yet. Sometimes tickets are issued into
3179240	3185000	the future. And this ticket will be valid at 8am. Because now 7am, you can still get a ticket, but
3185000	3191880	you can't print till 8am. And until, right? And a few other things. At least, it needs to include
3191880	3199080	something else called a session key. A session key is a short-term key generated by the trusted third party
3199080	3205960	server. For Alice and the server, for user and the server to communicate with. To protect their
3205960	3212040	communication. Does that make sense? Stop me if you lost me already.
3217480	3228600	So, now let's zoom in. How is an actual session with Kerberos going? Alice comes in the morning.
3229240	3237240	Alice wants to log in. She says, my name is Alice, user ID Alice, password, so and so on. The real
3237240	3245480	password is not really sentiment clear, okay? But the idea is that somehow it's something that allows
3246520	3253080	the trusted third party. Here it's called authentication server, and you'll see why. And when it
3253080	3258040	authenticates Alice, it will send back an encrypted ticket.
3262920	3268040	The problem with this approach is that the password would be in a clear text, or even a function of the
3268040	3273720	password would be in the clear text. And so an eavesdropper could essentially impersonate the user.
3273720	3279800	So you cannot send just encrypted password or clear text password, because that would be one.
3282520	3287640	And it would require you to do this for every service, right? So for every server which is not good.
3288680	3295720	So Kerberos adopts the following system. So here you see this dotted pink
3295720	3304440	contour around two entities. And then the reason that it's there is to say that there are two,
3304440	3310200	like you can think about two programs and two functions, but they're inside the same platform.
3310200	3316360	That means there's one device that runs both of them. One is called the key distribution center,
3316360	3319000	and one is called ticket granting service, but they're one in the same.
3319000	3324360	They're like two processes running in the same machine. And they are the TTP.
3326680	3327720	So the user
3333320	3341880	will come after having authenticated initially, right, and pooling his identity once, will go back and say,
3341880	3348760	hey, I want to access the PGS service. Okay, my name is Joe, in this case.
3351480	3357560	And the system will say, okay, you say your name is Joe. Notice no password. Notice no password there.
3357560	3363400	First message is no password. Just says, my name is Joe. I want to access the service called PGS,
3363400	3364600	Ticket Granting Service.
3364600	3373160	The trusted third party replies with an encrypted ticket granting service ticket,
3375720	3381800	where the ticket itself is encrypted under a key, you see it's green, derived from the user's password.
3384280	3391080	So that trusted third party knows the user's password and knows how to derive a key,
3391080	3396360	because we don't use password, because encryption is directly, right, when we hash them and derive them.
3397320	3405240	So that green contour means that the DGS ticket is encrypted with a key derived from the user's password.
3407400	3413240	Okay, now the user, if he knows the password, assuming that user knows the password, can decrypt the ticket.
3414040	3418840	And then come to the ticket granting service and say, hey, here is my ticket
3418840	3429080	that I was issued previously. Can you gain, can you give me access to a server, like printer, file,
3429080	3434920	server, storage device, whatever, view farm, and specify. And then get back and return,
3434920	3438920	if he's allowed to access that server, get back an encrypted service ticket.
3438920	3447400	Now, these two first lines, they happen, right, one after another. This and this happen one after another.
3448200	3452200	These two are not necessarily close, meaning this can happen an hour after.
3453400	3460120	Meaning that the user logs in, but the user doesn't use any service for a while, like doesn't need to print, right, doesn't need to do anything.
3460120	3468760	Maybe the user walks away or starts reading a book in the box station, right. But when the user actually wants to do something, then this happens.
3474520	3474920	And so,
3478280	3483080	stay away from me for a second. He gets the encrypted service ticket which he can decrypt.
3483080	3491000	Well, actually part of it, you'll see. This part he cannot because he doesn't know the yellow key.
3491560	3498120	The yellow key is the key of that service. And so he forwards it to the service and says, hey,
3499080	3501720	my name is Joe, I have a ticket to use you.
3505720	3509000	And that guy decrypts it, verifies it, and allows it.
3513080	3516600	The problem with this is that it's still not good enough because the ticket can be hijacked.
3516600	3518040	Because you see the ticket is sent,
3519560	3526600	kind of encrypted, right, and essentially anybody can intercept the ticket and hijack.
3532040	3533960	And the server,
3536760	3542600	so the printer, whatever, the file server, it needs to make sure that the user presenting the ticket
3542600	3546280	is the same to whom the ticket was originally issued by the DTP.
3549000	3549320	Okay.
3551080	3556920	Conversely, the server needs to authenticate to the user. So if the user thinks he got access to a printer
3556920	3562600	in the next room, okay, the user wants to make sure that he's talking to the printer in the next room
3562600	3568440	and not a printer across campus. Okay. So that's what's called mutual authentication.
3569000	3572760	The server needs to authenticate the user. The user needs to authenticate the server.
3575240	3579880	So now we are ready to look at the actual Kerberos. So in Kerberos here is the notation.
3581880	3588600	KC is the long-term key of a client C. The Kerberos uses the terminology client. The client is user.
3588600	3595160	Okay. It's derived from the user's password, known to the KDC, and the client.
3595160	3601160	TGS is the long-term key of the TGS. TGS, remember, is that part of the trusted enterprise, right,
3601160	3609000	and sits there all for that. Only it knows it, nobody else knows it. So this is not a shared key.
3609000	3614680	It's not a private key as in public private key, but it's a key only the TGS knows. So that's a
3614680	3624280	little weird. Key V is the long-term key of a server V, okay, like a printer server. V and TGS know it,
3624280	3632520	but nobody else does. Then this notation refers to a key that is short-term shared between the client,
3632520	3642280	Alice, Joe, and TGS. And KCV is the shorter term. This is called the session key, okay? That is,
3642280	3649080	will be shared between the user, client, and the server. You might get a little bleary at it at this
3649080	3656200	point. It won't become clear. So here's the actual single sign on the Kerberos.
3656200	3667720	So let's just finish on this slide. So the user has it on their device, whatever, a smartphone,
3667720	3673640	workstation, desktop, et cetera. He enters the password and there's a program that is client
3673640	3680520	programming. A purposeful key in it. You have to install it. And what it does is that program
3680520	3688680	actually communicates the KDC. So it converts the password into this long-term key, right,
3688680	3698680	that presumably is shared with the KDC. It then sends a clear text packet to the KDC or DTP. It
3698680	3705160	says the ID of the client, that's username, the ID of the TGS, that's reserved, that's kind of fixed,
3705160	3712840	the name of the TGS, and the current time, okay? Notice this packet is not protected. There's no
3712840	3722760	authentication. There's no encryption. If the user exists, right, right, because if they specify
3722760	3728280	ID that does not exist, they get no answer. But if the user exists and is in good standing,
3728280	3735160	meaning not revoked, not expunged, the KDC will reply to this green stuff, which is the encryption
3735160	3743160	under the client, under the user's long-term key of a short-term PTC, the blue key, that is to be used
3743160	3749240	from now on to talk to the DGS. The ID of the DGS should match the one in the blue, the issue should
3749240	3756760	match. The time, the KDC means that the time, the current time on that side of the KDC. Lifetime,
3757480	3763560	how long the ticket is valid, right? It's two from two. And a red thing, which by the way,
3763560	3767960	looks very small, but it's very important. It's a ticket for the DGS. So actually that red thing is
3767960	3776280	actually big, okay? It is an encrypted ticket that only DGS can read. So this green block comes to the
3776280	3782360	user, the user because assuming, assuming the user knows the right KDC, and this is not an impersonator,
3782360	3789160	right?
3789160	3796360	The crypt, the green part, learns KC DGS and ticket DGS, the orange one.
3796360	3803800	Okay? He also verifies that the time, for example, the time C and the time KDC have to be near. If
3803800	3809080	something is wrong there, you know, that's a, there's a problem with time synchronization,
3809080	3815880	right? If the ID DGS does not match, for example, right? You see, the user wants to go to one DGS,
3815880	3821800	the different DGS, again, it's a problem. It's an error. Otherwise, he obtains the
3821800	3832280	orange ticket DGS and that key, KC DGS. Okay? So that's the initial single sign-on. That is the
3832280	3842600	only time the user enters a password. That's it. Now, here's where I obtain a service ticket.
3843000	3848440	But since it's 1217, I think, let's just stop here.
3852120	3856200	Yeah, you all look a little confused by your own, by your own notation.
3857560	3863400	Trust me, if you stare at the slides for a little bit, it will all become clear.
3863400	3876840	You are right here.
3876840	3877800	Okay.
3881800	3882280	Okay.
3882280	3893720	Yeah.
